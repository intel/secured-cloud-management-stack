From 6732f30cd564811651c8800661b372785c3681b4 Mon Sep 17 00:00:00 2001
From: shaleijie <sha.leijie@99cloud.net>
Date: Sat, 12 Mar 2022 20:39:07 +0800
Subject: [PATCH 1/5] Add flavor extra spec parameters and image property for
 Intel Software Guard Extensions (SGX)

Add a new flavor extra spec parameter: "trait:HW_CPU_X86_SGX", and a new image property: "trait:HW_CPU_X86_SGX". Valuable settings for extra spec parameter are "required" or "forbidden", but "required" is the only valuable setting for image property. There is a conflict when extra spec parameter is set to "forbidden" and image property set to "required", which will cause guest's creation to fail. In other cases, the created guest's CPU has SGX features when one of extra spec parameter or image property is set to "required".
What's more, add a new flavor extra spec parameter: "resources:CUSTOM_SGX_EPC_MB", which indicates how much Enclave Page Cache (EPC) does the guest need. This parameter takes effect if guest's CPU has SGX features.
---
 doc/source/admin/intel-sgx.rst              | 107 ++++++++++++++++++++
 nova/compute/api.py                         |  12 +++
 nova/conf/libvirt.py                        |  62 ++++++++++++
 nova/tests/unit/virt/libvirt/test_driver.py |  59 +++++++++++
 nova/tests/unit/virt/libvirt/test_host.py   | 103 +++++++++++++++++++
 nova/tests/unit/virt/test_hardware.py       |  52 ++++++++++
 nova/virt/hardware.py                       |  24 +++++
 nova/virt/libvirt/config.py                 |  37 +++++++
 nova/virt/libvirt/driver.py                 |  51 ++++++++++
 nova/virt/libvirt/host.py                   |  39 ++++++-
 10 files changed, 545 insertions(+), 1 deletion(-)
 create mode 100755 doc/source/admin/intel-sgx.rst

diff --git a/doc/source/admin/intel-sgx.rst b/doc/source/admin/intel-sgx.rst
new file mode 100755
index 0000000..ce5a82f
--- /dev/null
+++ b/doc/source/admin/intel-sgx.rst
@@ -0,0 +1,107 @@
+INTEL SGX (Software Guard Extensions)
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+`Software Guard Extensions (SGX)`__ offers hardware-based memory
+encryption that isolates specific application code and data in memory.
+It allows user-level code to allocate private regions of memory, called
+enclaves, which are designed to be protected from processes running
+at higher privilege levels. By the passthrough of CPU SGX features,
+guests created on SGX-capable compute hosts can also run enclaves.
+
+__ https://www.intel.com/content/www/us/en/developer/tools/software-guard-extensions/overview.html
+
+Requirements for SGX
+--------------------
+
+First the operator will need to ensure the following prerequisites are met:
+
+- At least one of the Nova compute hosts must be INTEL hardware capable
+  of supporting SGX.  SGX control options are successfully enabled in BIOS.
+  It is entirely possible for the compute plane to be a mix of hardware which
+  can and cannot support SGX, the maximum number of simultaneously
+  running guests with SGX will be limited by the quantity and quality of
+  SGX-capable hardware available.
+
+- An appropriately configured software stack on those compute hosts,
+  so that the various layers are all SGX ready:
+
+  - kernel >= 4.16
+  - QEMU >= 2.12
+  - libvirt >= 4.5
+
+Deploying SGX-capable infrastructure
+------------------------------------
+
+In order for users to be able to use SGX, the operator will need to
+perform the following steps:
+
+- A cloud administrator will need to create SGX-enabled flavors and images.
+SGX-enabled flavor has `resources:CUSTOM_SGX_EPC_MB=xxx` and
+`trait:HW_CPU_X86_SGX=requried` in its extra specs. The value of `xxx`
+represents the memory size of EPC that guest needs, which is greater than 0 and
+less than the SGX-capable host's supply. SGX-enabled image has the property
+of `trait:HW_CPU_X86_SGX=required`.
+
+
+- Configure the :oslo.config:option:`libvirt.sgx_epc_mb` option
+  in :file:`nova.conf` to represent the EPC memory that
+  an SGX-capable compute host can provide to guests. For example:
+
+  .. code-block:: ini
+
+     [libvirt]
+     sgx_epc_mb = 256
+
+- Configure :oslo.config:option:`libvirt.sgx_features` option
+  in :file:`nova.conf` to represent the host's SGX CPU features which
+  should be passed to SGX guests. For example:
+
+  .. code-block:: ini
+
+  [libvirt]
+  sgx_features = sgx, sgxlc, sgx1, sgx-debug, sgx-mode64, sgx-provisionkey, sgx-tokenkey
+
+  .. caution::
+
+    The way Linux gets CPU features is through the CPUID instruction.
+    Libvirt file `/var/share/libvirt/cpu-map/x86-features.xml` defines
+    CPUID's input and output of each CPU feature. Through this file and
+    executing the CPUID instruction, Libvirt can obtain the features
+    supported by host's CPU. Features configured in option
+    `sgx_features` should be supported by host. Normally,
+    `/var/share/libvirt/cpu-map/x86-features.xml` does not contain
+    defintions of SGX features. The following needs to be added.
+
+    .. code-block:: xml
+
+    <!-- SGX features -->
+    <feature name="sgx">
+      <cpuid eax_in='0x07' ecx_in='0x00' ebx='0x00000004'/>
+    </feature>
+    <feature name="sgxlc">
+      <cpuid eax_in='0x07' ecx_in='0x00' ecx='0x40000000'/>
+    </feature>
+    <feature name="sgx1">
+      <cpuid eax_in='0x12' ecx_in='0x00' eax='0x00000001'/>
+    </feature>
+    <feature name="sgx-debug">
+      <cpuid eax_in='0x12' ecx_in='0x01' eax='0x00000002'/>
+    </feature>
+    <feature name="sgx-mode64">
+      <cpuid eax_in='0x12' ecx_in='0x01' eax='0x00000004'/>
+    </feature>
+    <feature name="sgx-provisionkey">
+      <cpuid eax_in='0x12' ecx_in='0x01' eax='0x00000010'/>
+    </feature>
+    <feature name="sgx-tokenkey">
+      <cpuid eax_in='0x12' ecx_in='0x01' eax='0x00000020'/>
+    </feature>
+
+
+Launching SGX instances
+-----------------------
+
+Once an operator has covered the above steps, users can launch SGX
+instances by requesting a SGX-enabled flavor. If the image used by
+SGX instances is not SGX-enable, users need to manually install
+the SGX driver. SGX-enabled image already contains the SGX driver
diff --git a/nova/compute/api.py b/nova/compute/api.py
index 4fa0cc2..5b6011b 100644
--- a/nova/compute/api.py
+++ b/nova/compute/api.py
@@ -741,6 +741,8 @@ class API(base.Base):
 
         API._validate_flavor_image_mem_encryption(instance_type, image_meta)
 
+        API._validate_flavor_image_sgx_epc(instance_type, image_meta)
+
         # validate PMU extra spec and image metadata
         flavor_pmu = instance_type.extra_specs.get('hw:pmu')
         image_pmu = image_meta.properties.get('hw_pmu')
@@ -772,6 +774,16 @@ class API(base.Base):
         # necessary; if not, we can ignore the result returned.
         hardware.get_mem_encryption_constraint(instance_type, image)
 
+    @staticmethod
+    def _validate_flavor_image_sgx_epc(flavor, image_meta):
+        """Validate contradictory.
+
+        :param instance_type: Flavor object
+        :param image: an ImageMeta object
+        :raises: nova.exception.FlavorImageConflict
+        """
+        hardware.get_sgx_trait_constraint(flavor, image_meta)
+
     def _get_image_defined_bdms(self, instance_type, image_meta,
                                 root_device_name):
         image_properties = image_meta.get('properties', {})
diff --git a/nova/conf/libvirt.py b/nova/conf/libvirt.py
index 1364c8e..0331342 100644
--- a/nova/conf/libvirt.py
+++ b/nova/conf/libvirt.py
@@ -894,6 +894,68 @@ Related options:
   :oslo.config:option:`libvirt.hw_machine_type`; see
   :ref:`deploying-sev-capable-infrastructure` for more on this.
 """),
+    cfg.IntOpt('sgx_epc_mb',
+               default=0,
+               min=0,
+               help="""
+Available capacity of SGX EPC in MiB for host's guests.
+This value should be less than SGX EPC configuration in host's BIOS.
+
+Set to 0 to disable SGX.
+
+Related options:
+
+* ``virt_type``: ``sgx_epc_mb`` has only value when ``virt_type``
+  set to kvm or qemu. SGX cannot be enabled on other hypervisors.
+
+"""),
+    cfg.ListOpt('sgx_features',
+                default=['sgx',
+                         'sgxlc',
+                         'sgx1',
+                         'sgx-debug',
+                         'sgx-mode64',
+                         'sgx-provisionkey',
+                         'sgx-tokenkey'],
+                help="""
+An list of SGX features should be added to the CPU of SGX guest.
+
+Add their definitions to Libvirt installation file
+``/usr/share/libvirt/cpu_map/x86_features.xml``::
+
+    <!-- SGX features -->
+    <feature name="sgx">
+      <cpuid eax_in='0x07' ecx_in='0x00' ebx='0x00000004'/>
+    </feature>
+    <feature name="sgxlc">
+      <cpuid eax_in='0x07' ecx_in='0x00' ecx='0x40000000'/>
+    </feature>
+    <feature name="sgx1">
+      <cpuid eax_in='0x12' ecx_in='0x00' eax='0x00000001'/>
+    </feature>
+    <feature name="sgx-debug">
+      <cpuid eax_in='0x12' ecx_in='0x01' eax='0x00000002'/>
+    </feature>
+    <feature name="sgx-mode64">
+      <cpuid eax_in='0x12' ecx_in='0x01' eax='0x00000004'/>
+    </feature>
+    <feature name="sgx-provisionkey">
+      <cpuid eax_in='0x12' ecx_in='0x01' eax='0x00000010'/>
+    </feature>
+    <feature name="sgx-tokenkey">
+      <cpuid eax_in='0x12' ecx_in='0x01' eax='0x00000020'/>
+    </feature>
+
+when definitions don't exist.
+
+Related options:
+
+* ``virt_type``: ``sgx_features`` has only value when ``virt_type``
+  set to kvm or qemu. SGX cannot be enabled on other hypervisors.
+
+* ``sgx_epc_mb``: If ``sgx_epc_mb`` is set to 0,
+  these features would not be added to guest CPU.
+""")
 ]
 
 libvirt_imagebackend_opts = [
diff --git a/nova/tests/unit/virt/libvirt/test_driver.py b/nova/tests/unit/virt/libvirt/test_driver.py
index dc613e0..e40cc43 100644
--- a/nova/tests/unit/virt/libvirt/test_driver.py
+++ b/nova/tests/unit/virt/libvirt/test_driver.py
@@ -25575,3 +25575,62 @@ class LibvirtPMEMNamespaceTests(test.NoDBTestCase):
               </devices>
             </domain>'''
         self.assertXmlEqual(expected, guest.to_xml())
+
+
+class TestLibvirtSGX(test.NoDBTestCase):
+    """Libvirt driver tests for Intel SGX"""
+
+    class Temp(dict):
+
+        def __getattr__(self, key):
+            return self.get(key)
+
+        def __setattr__(self, key, value):
+            self[key] = value
+
+
+    def setUp(self):
+        super(TestLibvirtSGX, self).setUp()
+        self.driver = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)
+
+    @mock.patch('nova.virt.libvirt.host.Host.supports_intel_sgx',
+                new=mock.Mock(return_value=False))
+    def test_get_host_sgx_epc_mb_zero(self):
+        self.assertEqual(0, self.driver._get_host_sgx_epc_mb())
+
+    @mock.patch('nova.virt.libvirt.host.Host.supports_intel_sgx',
+                new=mock.Mock(return_value=False))
+    def test_get_host_sgx_epc_mb_config(self):
+        self.flags(sgx_epc_mb=100, group='libvirt')
+        self.assertEqual(100, self.driver._get_host_sgx_epc_mb())
+
+    def test_guest_add_sgx_xen(self):
+        guest_tmp = self.Temp({'guest': None, 'virt_type': 'xen'})
+        result = self.driver._guest_add_sgx(guest_tmp, None, None)
+        self.assertIsNone(result)
+
+    @mock.patch('nova.virt.hardware.get_sgx_trait_constraint',
+                new=mock.Mock(return_value=False))
+    def test_guest_add_sgx_kvm_unrequire_sgx(self):
+        guest_tmp = self.Temp({'guest': None, 'virt_type': 'kvm'})
+        result = self.driver._guest_add_sgx(guest_tmp, None, None)
+        self.assertIsNone(result)
+
+    @mock.patch('nova.virt.hardware.get_sgx_trait_constraint',
+                new=mock.Mock(return_value=True))
+    def test_guest_add_sgx_kvm_require_sgx(self):
+        epc_size = 10
+        self.flags(sgx_features=[], group='libvirt')
+        guest_tmp = self.Temp({'guest': None, 'virt_type': 'kvm'})
+        flavor = self.Temp(
+            {'extra_specs': {
+                'resources:' + libvirt_driver.SGX_RESOURCE_CLASS: epc_size}
+            }
+        )
+        result = self.driver._guest_add_sgx(guest_tmp, flavor, None)
+        self.assertIsNone(result)
+        self.assertTrue(
+            isinstance(guest_tmp.sgx,
+                       vconfig.LibvirtConfigGuestQemuCommandLine))
+        _str = 'memory-backend-epc,id=mem1,size=%dM,prealloc=on' % epc_size
+        self.assertTrue(_str in guest_tmp.sgx.arguments)
diff --git a/nova/tests/unit/virt/libvirt/test_host.py b/nova/tests/unit/virt/libvirt/test_host.py
index 4c4b1d4..8ba12f8 100644
--- a/nova/tests/unit/virt/libvirt/test_host.py
+++ b/nova/tests/unit/virt/libvirt/test_host.py
@@ -1344,3 +1344,106 @@ class LibvirtTpoolProxyTestCase(test.NoDBTestCase):
         for domain in domains:
             self.assertIsInstance(domain, tpool.Proxy)
             self.assertIn(domain.UUIDString(), (uuids.vm1, uuids.vm2))
+
+
+class TestLibvirtSGXSupport(test.NoDBTestCase):
+    """Libvirt host tests for INTEL SGX."""
+
+    def setUp(self):
+        super(TestLibvirtSGXSupport, self).setUp()
+
+        self.useFixture(fakelibvirt.FakeLibvirtFixture())
+        self.host = host.Host("qemu:///system")
+
+    @mock.patch.object(os.path, 'exists', return_value=False)
+    def test_kernel_parameter_missing(self, fake_exists):
+        self.assertFalse(self.host._kernel_supports_intel_sgx())
+        fake_exists.assert_called_once_with(host.SGX_KERNEL_PARAM_FILE)
+
+    @mock.patch.object(os.path, 'exists', return_value=True)
+    @mock.patch.object(builtins, 'open', mock.mock_open(read_data="Y\n"))
+    def test_kernel_parameter_pass(self, fake_exists):
+        self.assertTrue(self.host._kernel_supports_intel_sgx())
+        fake_exists.assert_called_once_with(host.SGX_KERNEL_PARAM_FILE)
+
+    @mock.patch.object(os.path, 'exists', return_value=True)
+    @mock.patch.object(builtins, 'open', mock.mock_open(read_data="N\n"))
+    def test_kernel_parameter_fail(self, fake_exists):
+        self.assertFalse(self.host._kernel_supports_intel_sgx())
+        fake_exists.assert_called_once_with(host.SGX_KERNEL_PARAM_FILE)
+
+    @mock.patch('nova.virt.libvirt.host.Host._kernel_supports_intel_sgx',
+                new=mock.Mock(return_value=True))
+    def test_supports_intel_sgx(self):
+        fake_caps_xml = """
+<capabilities>
+    <host>
+        <uuid>cef19ce0-0ca2-11df-855d-b19fbce37686</uuid>
+        <cpu>
+            <arch>x86_64</arch>
+            <vendor>Intel</vendor>
+            <microcode version='218104544'/>
+            <counter name='tsc' frequency='2593882000' scaling='yes'/>
+            <feature name='sgx'/>
+            <feature name='sgxlc'/>
+            <feature name='sgx1'/>
+            <feature name='sgx-debug'/>
+            <feature name='sgx-mode64'/>
+            <feature name='sgx-provisionkey'/>
+            <feature name='sgx-tokenkey'/>
+        </cpu>
+    </host>
+</capabilities>"""
+        with mock.patch.object(fakelibvirt.virConnect, 'getCapabilities',
+                               return_value=fake_caps_xml):
+            features = ['sgx', 'sgxlc', 'sgx1', 'sgx-debug',
+                        'sgx-mode64', 'sgx-provisionkey', 'sgx-tokenkey']
+            self.flags(sgx_features=features, group='libvirt')
+            self.assertTrue(self.host.supports_intel_sgx)
+
+    @mock.patch('nova.virt.libvirt.host.Host._kernel_supports_intel_sgx',
+                new=mock.Mock(return_value=True))
+    def test_unsupports_intel_sgx_1(self):
+        fake_caps_xml = """
+<capabilities>
+    <host>
+        <uuid>cef19ce0-0ca2-11df-855d-b19fbce37686</uuid>
+        <cpu>
+            <arch>x86_64</arch>
+            <vendor>Intel</vendor>
+            <microcode version='218104544'/>
+            <counter name='tsc' frequency='2593882000' scaling='yes'/>
+        </cpu>
+    </host>
+</capabilities>"""
+        with mock.patch.object(fakelibvirt.virConnect, 'getCapabilities',
+                               return_value=fake_caps_xml):
+            features = ['sgx', 'sgxlc', 'sgx1', 'sgx-debug',
+                        'sgx-mode64', 'sgx-provisionkey', 'sgx-tokenkey']
+            self.flags(sgx_features=features, group='libvirt')
+            self.assertFalse(self.host.supports_intel_sgx)
+
+    @mock.patch('nova.virt.libvirt.host.Host._kernel_supports_intel_sgx',
+                new=mock.Mock(return_value=True))
+    def test_unsupports_intel_sgx_2(self):
+        fake_caps_xml = """
+<capabilities>
+    <host>
+        <uuid>cef19ce0-0ca2-11df-855d-b19fbce37686</uuid>
+        <cpu>
+            <arch>x86_64</arch>
+            <vendor>Intel</vendor>
+            <microcode version='218104544'/>
+            <counter name='tsc' frequency='2593882000' scaling='yes'/>
+            <feature name='sgx'/>
+            <feature name='sgxlc'/>
+            <feature name='sgx1'/>
+        </cpu>
+    </host>
+</capabilities>"""
+        with mock.patch.object(fakelibvirt.virConnect, 'getCapabilities',
+                               return_value=fake_caps_xml):
+            features = ['sgx', 'sgxlc', 'sgx1', 'sgx-debug',
+                        'sgx-mode64', 'sgx-provisionkey', 'sgx-tokenkey']
+            self.flags(sgx_features=features, group='libvirt')
+            self.assertFalse(self.host.supports_intel_sgx)
diff --git a/nova/tests/unit/virt/test_hardware.py b/nova/tests/unit/virt/test_hardware.py
index 772f05b..85a3e72 100644
--- a/nova/tests/unit/virt/test_hardware.py
+++ b/nova/tests/unit/virt/test_hardware.py
@@ -4368,3 +4368,55 @@ class MemEncryptionRequiredTestCase(test.NoDBTestCase):
                     "hw_mem_encryption property of image %s" %
                     (self.flavor_name, self.image_name)
                 )
+
+
+class SGXRequiredTestCase(test.NoDBTestCase):
+    flavor_name = 'm1.faketiny'
+    image_name = 'fakecirros'
+    image_id = '7ec4448e-f3fd-44b1-b172-9a7980f0f29f'
+
+    def _test_get_sgx_trait_constraint(self, extra_specs, image_props, assert_func):
+        flavor = objects.Flavor(name=self.flavor_name,
+                                extra_specs=extra_specs)
+        image_meta = objects.ImageMeta.from_dict({
+            'id': self.image_id,
+            'name': self.image_name,
+            'properties': image_props})
+        if assert_func in [self.assertTrue, self.assertFalse]:
+            assert_func(hw.get_sgx_trait_constraint(flavor, image_meta))
+        if assert_func == self.assertRaises:
+            assert_func(exception.FlavorImageConflict,
+                        hw.get_sgx_trait_constraint, flavor, image_meta)
+
+    def test_sgx_trait_flavor_and_image_constraint(self):
+        trait_name = "trait:HW_CPU_X86_SGX"
+        # `cases` is a list of tuples. elements in each tuple represents:
+        # flavor spec, image prop and assert func.
+        cases = [
+            (None, None, self.assertFalse),
+            (None, 'required', self.assertTrue),
+            (None, 'forbidden', self.assertFalse),
+            (None, 'other', self.assertFalse),
+            ('required', None, self.assertTrue),
+            ('required', 'required', self.assertTrue),
+            ('required', 'forbidden', self.assertTrue),
+            ('required', 'other', self.assertTrue),
+            ('forbidden', None, self.assertFalse),
+            ('forbidden', 'required', self.assertRaises),
+            ('forbidden', 'forbidden', self.assertFalse),
+            ('forbidden', 'other', self.assertFalse),
+            ('other', 'None', self.assertFalse),
+            ('other', 'required', self.assertTrue),
+            ('other', 'forbidden', self.assertFalse),
+            ('other', 'other', self.assertFalse),
+        ]
+        for case in cases:
+            flavor_epc, image_epc, assert_func = case
+            extra_specs = {}
+            if flavor_epc is not None:
+                extra_specs[trait_name] = flavor_epc
+            image_props = {}
+            if image_epc is not None:
+                image_props[trait_name] = image_epc
+            self._test_get_sgx_trait_constraint(
+                extra_specs, image_props, assert_func)
diff --git a/nova/virt/hardware.py b/nova/virt/hardware.py
index 1a22c6b..cb2c8e2 100644
--- a/nova/virt/hardware.py
+++ b/nova/virt/hardware.py
@@ -2253,3 +2253,27 @@ def get_vpmems(flavor):
         if formed_label:
             formed_labels.append(formed_label)
     return formed_labels
+
+
+def get_sgx_trait_constraint(flavor, image_meta):
+    # return whether
+    trait_name = "HW_CPU_X86_SGX"
+    flavor_str = flavor.get(
+        'extra_specs', {}).get('trait:' + trait_name, None)
+
+    traits = image_meta.properties.get('traits_required', [])
+    image_require_sgx = trait_name in traits
+    if flavor_str == "forbidden" and image_require_sgx:
+        emsg = _(
+            "Flavor %(flavor_name)s has trait:HW_CPU_X86_SGX extra spec "
+            "explicitly set to forbidden, conflicting with image"
+            "%(image_name)s which has trait:HW_CPU_X86_SGX property "
+            "explicitly set to required."
+        )
+        data = {
+            'flavor_name': flavor.name,
+            'image_name': image_meta.name,
+        }
+        raise exception.FlavorImageConflict(emsg % data)
+
+    return flavor_str == "required" or image_require_sgx
diff --git a/nova/virt/libvirt/config.py b/nova/virt/libvirt/config.py
index 39c4da8..d4be341 100644
--- a/nova/virt/libvirt/config.py
+++ b/nova/virt/libvirt/config.py
@@ -39,6 +39,7 @@ from nova.virt import hardware
 
 # Namespace to use for Nova specific metadata items in XML
 NOVA_NS = "http://openstack.org/xmlns/libvirt/nova/1.0"
+QEMU_NS = "http://libvirt.org/schemas/domain/qemu/1.0"
 
 
 class LibvirtConfigObject(object):
@@ -2566,6 +2567,35 @@ class LibvirtConfigGuestSEVLaunchSecurity(LibvirtConfigObject):
         return root
 
 
+class LibvirtConfigGuestQemuCommandLine(LibvirtConfigObject):
+
+    def __init__(self, **kwargs):
+        super(LibvirtConfigGuestQemuCommandLine, self).__init__(
+            root_name='commandline', ns_prefix="qemu", ns_uri=QEMU_NS)
+        # List of strings, each item is the argument of the command line.
+        # For example, launch a SGX guest with the cmd:
+        # `qemu-system-x86_64 \
+        # -cpu host,+sgx-provisionkey \
+        # -object memory-backend-epc,id=mem1,size=64M,prealloc=on \
+        # -M sgx-epc.0.memdev=mem1,sgx-epc.0.node=0`,
+        # arguments will be:
+        # ['-cpu',
+        #  'host,+sgx-provisionkey',
+        #  '-object',
+        #  'memory-backend-epc,id=mem1,size=64M,prealloc=on',
+        #  '-M',
+        #  'sgx-epc.0.memdev=mem1,sgx-epc.0.node=0']
+        self.arguments = []
+
+    def format_dom(self):
+        cmdline = super(LibvirtConfigGuestQemuCommandLine, self).format_dom()
+        for argument in self.arguments:
+            arg = self._new_node("arg")
+            arg.set("value", argument)
+            cmdline.append(arg)
+        return cmdline
+
+
 class LibvirtConfigGuest(LibvirtConfigObject):
 
     def __init__(self, **kwargs):
@@ -2605,6 +2635,7 @@ class LibvirtConfigGuest(LibvirtConfigObject):
         self.idmaps = []
         self.perf_events = []
         self.launch_security = None
+        self.sgx = None
 
     def _format_basic_props(self, root):
         root.append(self._text_node("uuid", self.uuid))
@@ -2705,6 +2736,10 @@ class LibvirtConfigGuest(LibvirtConfigObject):
         if self.launch_security is not None:
             root.append(self.launch_security.format_dom())
 
+    def _format_sgx(self, root):
+        if self.sgx is not None:
+            root.append(self.sgx.format_dom())
+
     def format_dom(self):
         root = super(LibvirtConfigGuest, self).format_dom()
 
@@ -2735,6 +2770,8 @@ class LibvirtConfigGuest(LibvirtConfigObject):
 
         self._format_sev(root)
 
+        self._format_sgx(root)
+
         return root
 
     def _parse_basic_props(self, xmldoc):
diff --git a/nova/virt/libvirt/driver.py b/nova/virt/libvirt/driver.py
index f51463f..65c7ce0 100644
--- a/nova/virt/libvirt/driver.py
+++ b/nova/virt/libvirt/driver.py
@@ -162,6 +162,8 @@ CONSOLE = "console=tty0 console=ttyS0 console=hvc0"
 GuestNumaConfig = collections.namedtuple(
     'GuestNumaConfig', ['cpuset', 'cputune', 'numaconfig', 'numatune'])
 
+SGX_RESOURCE_CLASS = "CUSTOM_SGX_EPC_MB"
+
 
 class InjectionInfo(collections.namedtuple(
         'InjectionInfo', ['network_info', 'files', 'admin_pass'])):
@@ -5868,6 +5870,9 @@ class LibvirtDriver(driver.ComputeDriver):
             self._guest_configure_sev(guest, caps.host.cpu.arch,
                                       guest.os_mach_type)
 
+        if self._host.supports_intel_sgx:
+            self._guest_add_sgx(guest, flavor, image_meta)
+
         if vpmems:
             self._guest_add_vpmems(guest, vpmems)
 
@@ -5944,6 +5949,13 @@ class LibvirtDriver(driver.ComputeDriver):
         return hardware.get_mem_encryption_constraint(flavor, image_meta,
                                                       mach_type)
 
+    def _get_guest_sgx_epc_mb(self, flavor):
+        """Size of sgx epc memory is determined by
+        `resources:CUSTOM_SGX_EPC_MB` specified in flavor extra_spec.
+        """
+        epc_mb = flavor.extra_specs.get('resources:' + SGX_RESOURCE_CLASS)
+        return None if epc_mb is None else int(epc_mb)
+
     def _guest_configure_sev(self, guest, arch, mach_type):
         sev = self._find_sev_feature(arch, mach_type)
         if sev is None:
@@ -5969,6 +5981,27 @@ class LibvirtDriver(driver.ComputeDriver):
         launch_security.reduced_phys_bits = sev.reduced_phys_bits
         guest.launch_security = launch_security
 
+    def _guest_add_sgx(self, guest, flavor, image_meta):
+        if guest.virt_type in ('qemu', 'kvm'):
+            if hardware.get_sgx_trait_constraint(flavor, image_meta):
+                for flag in CONF.libvirt.sgx_features:
+                    guest.cpu.add_feature(
+                        vconfig.LibvirtConfigGuestCPUFeature(flag))
+            else:
+                return
+            sgx_epc_mb = self._get_guest_sgx_epc_mb(flavor)
+            if sgx_epc_mb is None:
+                return
+            sgx_qemu_commandline = vconfig.LibvirtConfigGuestQemuCommandLine()
+            sgx_qemu_commandline.arguments = [
+                '-object',
+                'memory-backend-epc,id=mem1,size=%dM,'
+                'prealloc=on' % sgx_epc_mb,
+                '-M',
+                'sgx-epc.0.memdev=mem1'
+            ]
+            guest.sgx = sgx_qemu_commandline
+
     def _find_sev_feature(self, arch, mach_type):
         """Search domain capabilities for the given arch and machine type
         for the <sev> element under <features>, and return it if found.
@@ -7363,6 +7396,7 @@ class LibvirtDriver(driver.ComputeDriver):
         vcpus = len(self._get_vcpu_available())
         pcpus = len(self._get_pcpu_available())
         memory_enc_slots = self._get_memory_encrypted_slots()
+        sgx_epc_mb = self._get_host_sgx_epc_mb()
 
         # NOTE(yikun): If the inv record does not exists, the allocation_ratio
         # will use the CONF.xxx_allocation_ratio value if xxx_allocation_ratio
@@ -7414,6 +7448,16 @@ class LibvirtDriver(driver.ComputeDriver):
                 'reserved': 0,
             }
 
+        if sgx_epc_mb:
+            result[SGX_RESOURCE_CLASS] = {
+                'total': sgx_epc_mb,
+                'min_unit': 1,
+                'max_unit': sgx_epc_mb,
+                'step_size': 1,
+                'allocation_ratio': 1,
+                'reserved': 0,
+            }
+
         # If a sharing DISK_GB provider exists in the provider tree, then our
         # storage is shared, and we should not report the DISK_GB inventory in
         # the compute node provider.
@@ -7512,6 +7556,12 @@ class LibvirtDriver(driver.ComputeDriver):
         else:
             return db_const.MAX_INT
 
+    def _get_host_sgx_epc_mb(self):
+        if not self._host.supports_intel_sgx:
+            return 0
+        else:
+            return CONF.libvirt.sgx_epc_mb
+
     @staticmethod
     def _is_reshape_needed_vgpu_on_root(provider_tree, nodename):
         """Determine if root RP has VGPU inventories.
@@ -10568,6 +10618,7 @@ class LibvirtDriver(driver.ComputeDriver):
         """
         traits = self._get_cpu_feature_traits()
         traits[ot.HW_CPU_X86_AMD_SEV] = self._host.supports_amd_sev
+        traits[ot.HW_CPU_X86_SGX] = self._host.supports_intel_sgx
         traits[ot.HW_CPU_HYPERTHREADING] = self._host.has_hyperthreading
 
         return traits
diff --git a/nova/virt/libvirt/host.py b/nova/virt/libvirt/host.py
index d8078dd..481aae0 100644
--- a/nova/virt/libvirt/host.py
+++ b/nova/virt/libvirt/host.py
@@ -77,7 +77,7 @@ HV_DRIVER_QEMU = "QEMU"
 HV_DRIVER_XEN = "Xen"
 
 SEV_KERNEL_PARAM_FILE = '/sys/module/kvm_amd/parameters/sev'
-
+SGX_KERNEL_PARAM_FILE = '/sys/module/kvm_intel/parameters/sgx'
 
 class Host(object):
 
@@ -118,6 +118,7 @@ class Host(object):
         # qemu, and libvirt.  This is determined on demand and
         # memoized by the supports_amd_sev property below.
         self._supports_amd_sev = None
+        self._supports_intel_sgx = None
 
         self._has_hyperthreading = None
 
@@ -1231,6 +1232,16 @@ class Host(object):
             LOG.debug("%s contains [%s]", SEV_KERNEL_PARAM_FILE, contents)
             return contents == "1\n"
 
+    def _kernel_supports_intel_sgx(self):
+        if not os.path.exists(SGX_KERNEL_PARAM_FILE):
+            LOG.debug("%s does not exist", SGX_KERNEL_PARAM_FILE)
+            return False
+
+        with open(SGX_KERNEL_PARAM_FILE) as f:
+            contents = f.read()
+            LOG.debug("%s contains [%s]", SGX_KERNEL_PARAM_FILE, contents)
+            return contents == "Y\n"
+
     @property
     def supports_amd_sev(self):
         """Returns a boolean indicating whether AMD SEV (Secure Encrypted
@@ -1247,6 +1258,16 @@ class Host(object):
             self._set_amd_sev_support()
         return self._supports_amd_sev
 
+    @property
+    def supports_intel_sgx(self):
+        """Returns a boolean indicating whether INTEL SGX (Software Guard
+        Extensions) is supported. This is conditional on support
+        in the hardware, kernel, qemu, and libvirt.
+        """
+        if self._supports_intel_sgx is None:
+            self._set_intel_sgx_support()
+        return self._supports_intel_sgx
+
     def _set_amd_sev_support(self):
         self._supports_amd_sev = False
 
@@ -1269,3 +1290,19 @@ class Host(object):
                         return
 
         LOG.debug("No AMD SEV support detected for any (arch, machine_type)")
+
+    def _set_intel_sgx_support(self):
+        self._supports_intel_sgx = False
+
+        if not self._kernel_supports_intel_sgx():
+            LOG.info("Kernel doesn't support INTEL SGX")
+            return
+
+        # Host CPU should have SGX features defined in CONF.
+        caps = self.get_capabilities()
+        feature_names = [f.name for f in caps.host.cpu.features]
+        if not set(CONF.libvirt.sgx_features).issubset(feature_names):
+            LOG.info("Host does not support SGX features")
+            return
+
+        self._supports_intel_sgx = True
-- 
2.17.1


From 4c4dfe926e652813a54df403bd6ca0ccc30a1922 Mon Sep 17 00:00:00 2001
From: shaleijie <sha.leijie@99cloud.net>
Date: Sat, 14 May 2022 01:50:28 +0800
Subject: [PATCH 2/5] Add quota support for SGX

---
 .../openstack/compute/flavors_extraspecs.py   |  12 +-
 .../openstack/compute/schemas/quota_sets.py   |   1 +
 nova/compute/api.py                           |   3 +-
 nova/compute/utils.py                         |  52 +++++----
 nova/conf/quota.py                            |  11 ++
 nova/objects/flavor.py                        |  13 +++
 nova/objects/instance.py                      |  41 ++++---
 nova/quota.py                                 |  12 +-
 nova/scheduler/client/report.py               |   8 +-
 nova/scheduler/utils.py                       |  12 +-
 nova/tests/fixtures.py                        |   8 ++
 .../openstack/compute/test_quota_classes.py   |   6 +-
 .../unit/api/openstack/compute/test_quotas.py |  22 +++-
 nova/tests/unit/compute/test_compute.py       |   3 +-
 nova/tests/unit/compute/test_compute_api.py   |  56 ++++++----
 nova/tests/unit/compute/test_compute_utils.py |  29 +++--
 nova/tests/unit/conductor/test_conductor.py   |   3 +-
 nova/tests/unit/db/fakes.py                   |   1 +
 nova/tests/unit/objects/test_objects.py       |   2 +-
 .../unit/scheduler/client/test_report.py      |  21 ++--
 nova/tests/unit/test_fixtures.py              |   2 +-
 nova/tests/unit/test_flavors.py               |   5 +-
 nova/tests/unit/test_quota.py                 | 103 +++++++++++++++++-
 nova/tests/unit/virt/libvirt/test_driver.py   |   2 +-
 nova/utils.py                                 |   6 +
 nova/virt/libvirt/driver.py                   |   6 +-
 26 files changed, 326 insertions(+), 114 deletions(-)

diff --git a/nova/api/openstack/compute/flavors_extraspecs.py b/nova/api/openstack/compute/flavors_extraspecs.py
index a5c5c5e..69e4c59 100644
--- a/nova/api/openstack/compute/flavors_extraspecs.py
+++ b/nova/api/openstack/compute/flavors_extraspecs.py
@@ -32,11 +32,21 @@ class FlavorExtraSpecsController(wsgi.Controller):
         flavor = common.get_flavor(context, flavor_id)
         return dict(extra_specs=flavor.extra_specs)
 
+    def _extra_check_for_sgx_epc(self, value):
+        if isinstance(value, (six.integer_types,)) and value > 0:
+            return
+        raise exception.InvalidInput(
+            reason="%s must be a positive integer." % utils.SGX_RESOURCE_EPC)
+
     # NOTE(gmann): Max length for numeric value is being checked
     # explicitly as json schema cannot have max length check for numeric value
     def _check_extra_specs_value(self, specs):
-        for value in specs.values():
+        for key, value in specs.items():
             try:
+                # extra check for SGX_RESOURCE_EPC, which should be a positive integer
+                if key == utils.SGX_RESOURCE_EPC:
+                    self._extra_check_for_sgx_epc(value)
+
                 if isinstance(value, (six.integer_types, float)):
                     value = six.text_type(value)
                     utils.check_string_length(value, 'extra_specs value',
diff --git a/nova/api/openstack/compute/schemas/quota_sets.py b/nova/api/openstack/compute/schemas/quota_sets.py
index fe45df7..9edd8a7 100644
--- a/nova/api/openstack/compute/schemas/quota_sets.py
+++ b/nova/api/openstack/compute/schemas/quota_sets.py
@@ -30,6 +30,7 @@ quota_resources = {
     'instances': common_quota,
     'cores': common_quota,
     'ram': common_quota,
+    'sgx_epc': common_quota,
     'floating_ips': common_quota,
     'fixed_ips': common_quota,
     'metadata_items': common_quota,
diff --git a/nova/compute/api.py b/nova/compute/api.py
index 5b6011b..d3dfd73 100644
--- a/nova/compute/api.py
+++ b/nova/compute/api.py
@@ -3534,7 +3534,8 @@ class API(base.Base):
         if deltas:
             try:
                 res_deltas = {'cores': deltas.get('cores', 0),
-                              'ram': deltas.get('ram', 0)}
+                              'ram': deltas.get('ram', 0),
+                              'sgx_epc': deltas.get('sgx_epc', 0)}
                 objects.Quotas.check_deltas(context, res_deltas,
                                             project_id, user_id=user_id,
                                             check_project_id=project_id,
diff --git a/nova/compute/utils.py b/nova/compute/utils.py
index 7fc9553..c649a12 100644
--- a/nova/compute/utils.py
+++ b/nova/compute/utils.py
@@ -1023,11 +1023,22 @@ def upsize_quota_delta(new_flavor, old_flavor):
     def _quota_delta(resource):
         return (new_flavor[resource] - old_flavor[resource])
 
+    def _quota_delta_sgx_epc():
+
+        def _value(flavor):
+            if flavor.extra_specs is not None:
+                return int(flavor.extra_specs.get(utils.SGX_RESOURCE_EPC, 0))
+            return 0
+
+        return _value(new_flavor) - _value(old_flavor)
+
     deltas = {}
     if _quota_delta('vcpus') > 0:
         deltas['cores'] = _quota_delta('vcpus')
     if _quota_delta('memory_mb') > 0:
         deltas['ram'] = _quota_delta('memory_mb')
+    if _quota_delta_sgx_epc() > 0:
+        deltas['sgx_epc'] = _quota_delta_sgx_epc()
 
     return deltas
 
@@ -1035,24 +1046,15 @@ def upsize_quota_delta(new_flavor, old_flavor):
 def get_headroom(quotas, usages, deltas):
     headroom = {res: quotas[res] - usages[res]
                 for res in quotas.keys()}
-    # If quota_cores is unlimited [-1]:
-    # - set cores headroom based on instances headroom:
-    if quotas.get('cores') == -1:
-        if deltas.get('cores'):
-            hc = headroom.get('instances', 1) * deltas['cores']
-            headroom['cores'] = hc / deltas.get('instances', 1)
-        else:
-            headroom['cores'] = headroom.get('instances', 1)
-
-    # If quota_ram is unlimited [-1]:
-    # - set ram headroom based on instances headroom:
-    if quotas.get('ram') == -1:
-        if deltas.get('ram'):
-            hr = headroom.get('instances', 1) * deltas['ram']
-            headroom['ram'] = hr / deltas.get('instances', 1)
-        else:
-            headroom['ram'] = headroom.get('instances', 1)
-
+    # If quota_cores, quota_ram, and quota_sgx_epc is unlimited [-1]:
+    # - set headroom of them based on instances headroom:
+    for item in ['cores', 'ram', 'sgx_epc']:
+        if quotas.get(item) == -1:
+            if deltas.get(item):
+                hc = headroom.get('instances', 1) * deltas[item]
+                headroom[item] = hc /deltas.get('instances', 1)
+            else:
+                headroom[item] = headroom.get('instances', 1)
     return headroom
 
 
@@ -1066,7 +1068,11 @@ def check_num_instances_quota(context, instance_type, min_count,
     # Determine requested cores and ram
     req_cores = max_count * instance_type.vcpus
     req_ram = max_count * instance_type.memory_mb
-    deltas = {'instances': max_count, 'cores': req_cores, 'ram': req_ram}
+    sgx_epc = int(instance_type.extra_specs.get(utils.SGX_RESOURCE_EPC, 0))
+    req_sgx_epc = max_count * sgx_epc
+
+    deltas = {'instances': max_count, 'cores': req_cores,
+              'ram': req_ram, 'sgx_epc': req_sgx_epc}
 
     try:
         objects.Quotas.check_deltas(context, deltas,
@@ -1083,8 +1089,9 @@ def check_num_instances_quota(context, instance_type, min_count,
             # case of a recheck quota, for use in the over quota exception.
             req_cores = orig_num_req * instance_type.vcpus
             req_ram = orig_num_req * instance_type.memory_mb
+            req_sgx_epc = orig_num_req * sgx_epc
             requested = {'instances': orig_num_req, 'cores': req_cores,
-                         'ram': req_ram}
+                         'ram': req_ram, 'sgx_epc': req_sgx_epc}
             (overs, reqs, total_alloweds, useds) = get_over_quota_detail(
                 deltas, overs, quotas, requested)
             msg = "Cannot run any more instances of this type."
@@ -1106,6 +1113,9 @@ def check_num_instances_quota(context, instance_type, min_count,
         if instance_type.memory_mb:
             allowed = min(allowed,
                           headroom['ram'] // instance_type.memory_mb)
+        if sgx_epc:
+            allowed = min(allowed,
+                          headroom['sgx_epc'] // sgx_epc)
 
         # Convert to the appropriate exception message
         if allowed <= 0:
@@ -1121,7 +1131,7 @@ def check_num_instances_quota(context, instance_type, min_count,
         num_instances = (str(min_count) if min_count == max_count else
             "%s-%s" % (min_count, max_count))
         requested = dict(instances=num_instances, cores=req_cores,
-                         ram=req_ram)
+                         ram=req_ram, sgx_epc=req_sgx_epc)
         (overs, reqs, total_alloweds, useds) = get_over_quota_detail(
             headroom, overs, quotas, requested)
         params = {'overs': overs, 'pid': project_id,
diff --git a/nova/conf/quota.py b/nova/conf/quota.py
index 06c10bc..88fd473 100644
--- a/nova/conf/quota.py
+++ b/nova/conf/quota.py
@@ -61,6 +61,17 @@ The number of megabytes of instance RAM allowed per project.
 
 Possible values:
 
+* A positive integer or 0.
+* -1 to disable the quota.
+"""),
+    cfg.IntOpt('sgx_epc',
+        min=-1,
+        default=1 * 1024,
+        help="""
+The number of megabytes of instance SGX EPC allowed per project.
+
+Possible values:
+
 * A positive integer or 0.
 * -1 to disable the quota.
 """),
diff --git a/nova/objects/flavor.py b/nova/objects/flavor.py
index c590fc1..d59f7a3 100644
--- a/nova/objects/flavor.py
+++ b/nova/objects/flavor.py
@@ -134,6 +134,15 @@ def _flavor_extra_specs_del(context, flavor_id, key):
             extra_specs_key=key, flavor_id=flavor_id)
 
 
+@db_api.api_context_manager.reader
+def _get_all_extra_specs_by_key(context, key):
+    records = context.session.query(
+        api_models.FlavorExtraSpecs.flavor_id,
+        api_models.FlavorExtraSpecs.value).filter_by(key=key).all()
+
+    return {record[0]: int(record[1]) or 0 for record in records}
+
+
 @db_api.api_context_manager.writer
 def _flavor_create(context, values):
     specs = values.get('extra_specs')
@@ -649,3 +658,7 @@ class FlavorList(base.ObjectListBase, base.NovaObject):
         return base.obj_make_list(context, cls(context), objects.Flavor,
                                   api_db_flavors,
                                   expected_attrs=['extra_specs'])
+
+    @staticmethod
+    def get_all_extra_specs_by_key(context, key):
+        return _get_all_extra_specs_by_key(context, key)
diff --git a/nova/objects/instance.py b/nova/objects/instance.py
index ba0ea15..0a7f6a6 100644
--- a/nova/objects/instance.py
+++ b/nova/objects/instance.py
@@ -1491,7 +1491,7 @@ class InstanceList(base.ObjectListBase, base.NovaObject):
 
     @staticmethod
     @db_api.pick_context_manager_reader
-    def _get_counts_in_db(context, project_id, user_id=None):
+    def _get_counts_in_db(context, project_id, user_id=None, **kwargs):
         # NOTE(melwitt): Copied from nova/db/sqlalchemy/api.py:
         # It would be better to have vm_state not be nullable
         # but until then we test it explicitly as a workaround.
@@ -1502,31 +1502,41 @@ class InstanceList(base.ObjectListBase, base.NovaObject):
         project_query = context.session.query(
             func.count(models.Instance.id),
             func.sum(models.Instance.vcpus),
-            func.sum(models.Instance.memory_mb)).\
+            func.sum(models.Instance.memory_mb),
+            models.Instance.instance_type_id).\
             filter_by(deleted=0).\
             filter(not_soft_deleted).\
-            filter_by(project_id=project_id)
+            filter_by(project_id=project_id).\
+            group_by(models.Instance.instance_type_id)
         # NOTE(mriedem): Filter out hidden instances since there should be a
         # non-hidden version of the instance in another cell database and the
         # API will only show one of them, so we don't count the hidden copy.
         project_query = project_query.filter(
             or_(models.Instance.hidden == false(),
                 models.Instance.hidden == null()))
-
-        project_result = project_query.first()
-        fields = ('instances', 'cores', 'ram')
-        project_counts = {field: int(project_result[idx] or 0)
-                          for idx, field in enumerate(fields)}
-        counts = {'project': project_counts}
+        project_results = project_query.all()
+
+        flavor_epc_mappings = kwargs.get("flavor_epc_mappings", {})
+
+        def _counts(db_results):
+            result = {'instances': 0, 'cores': 0, 'ram': 0, 'sgx_epc': 0}
+            for db_result in db_results:
+                num_instances = int(db_result[0] or 0)
+                result['instances'] += num_instances
+                result['cores'] += int(db_result[1] or 0)
+                result['ram'] += int(db_result[2] or 0)
+                epc_size = flavor_epc_mappings.get(db_result[3], 0) * num_instances
+                result['sgx_epc'] += epc_size
+            return result
+
+        counts = {'project': _counts(project_results)}
         if user_id:
-            user_result = project_query.filter_by(user_id=user_id).first()
-            user_counts = {field: int(user_result[idx] or 0)
-                           for idx, field in enumerate(fields)}
-            counts['user'] = user_counts
+            user_results = project_query.filter_by(user_id=user_id).all()
+            counts['user'] = _counts(user_results)
         return counts
 
     @base.remotable_classmethod
-    def get_counts(cls, context, project_id, user_id=None):
+    def get_counts(cls, context, project_id, user_id=None, **kwargs):
         """Get the counts of Instance objects in the database.
 
         :param context: The request context for database access
@@ -1542,7 +1552,8 @@ class InstanceList(base.ObjectListBase, base.NovaObject):
                               'cores': <count across user>,
                               'ram': <count across user>}}
         """
-        return cls._get_counts_in_db(context, project_id, user_id=user_id)
+        return cls._get_counts_in_db(
+            context, project_id, user_id=user_id, **kwargs)
 
     @staticmethod
     @db_api.pick_context_manager_reader
diff --git a/nova/quota.py b/nova/quota.py
index 314eabd..d7c97a3 100644
--- a/nova/quota.py
+++ b/nova/quota.py
@@ -1242,12 +1242,17 @@ def _instances_cores_ram_count_legacy(context, project_id, user_id=None):
     else:
         nova_context.load_cells()
         cell_mappings = nova_context.CELLS
+    flavor_epc_mappings = objects.FlavorList.get_all_extra_specs_by_key(
+        context, utils.SGX_RESOURCE_EPC)
     results = nova_context.scatter_gather_cells(
         context, cell_mappings, nova_context.CELL_TIMEOUT,
-        objects.InstanceList.get_counts, project_id, user_id=user_id)
-    total_counts = {'project': {'instances': 0, 'cores': 0, 'ram': 0}}
+        objects.InstanceList.get_counts, project_id, user_id=user_id,
+        flavor_epc_mappings=flavor_epc_mappings)
+    total_counts = {
+        'project': {'instances': 0, 'cores': 0, 'ram': 0, 'sgx_epc': 0}}
     if user_id:
-        total_counts['user'] = {'instances': 0, 'cores': 0, 'ram': 0}
+        total_counts['user'] = {
+            'instances': 0, 'cores': 0, 'ram': 0, 'sgx_epc': 0}
     for result in results.values():
         if not nova_context.is_cell_failure_sentinel(result):
             for resource, count in result['project'].items():
@@ -1355,6 +1360,7 @@ QUOTAS = QuotaEngine(
             'cores', _instances_cores_ram_count, 'cores'),
         CountableResource(
             'ram', _instances_cores_ram_count, 'ram'),
+        CountableResource('sgx_epc', _instances_cores_ram_count, 'sgx_epc'),
         CountableResource(
             'security_groups', _security_group_count, 'security_groups'),
         CountableResource(
diff --git a/nova/scheduler/client/report.py b/nova/scheduler/client/report.py
index 98eb816..bd3e4d8 100644
--- a/nova/scheduler/client/report.py
+++ b/nova/scheduler/client/report.py
@@ -2352,7 +2352,9 @@ class SchedulerReportClient(object):
             # there is no usage. We can consider a missing class to be 0 usage.
             cores = _get_core_usages(data)
             ram = data['usages'].get(orc.MEMORY_MB, 0)
-            total_counts['project'] = {'cores': cores, 'ram': ram}
+            sgx_epc = data['usages'].get(utils.SGX_RESOURCE_CLASS, 0)
+            total_counts['project'] = {
+                'cores': cores, 'ram': ram, 'sgx_epc': sgx_epc}
         else:
             self._handle_usages_error_from_placement(resp, project_id)
         # If specified, second query counts across one user in the project
@@ -2364,7 +2366,9 @@ class SchedulerReportClient(object):
                 data = resp.json()
                 cores = _get_core_usages(data)
                 ram = data['usages'].get(orc.MEMORY_MB, 0)
-                total_counts['user'] = {'cores': cores, 'ram': ram}
+                sgx_epc = data['usages'].get(utils.SGX_RESOURCE_CLASS, 0)
+                total_counts['user'] = {
+                    'cores': cores, 'ram': ram, 'sgx_epc': sgx_epc}
             else:
                 self._handle_usages_error_from_placement(resp, project_id,
                                                          user_id=user_id)
diff --git a/nova/scheduler/utils.py b/nova/scheduler/utils.py
index bd6adbe..befb7d3 100644
--- a/nova/scheduler/utils.py
+++ b/nova/scheduler/utils.py
@@ -37,6 +37,7 @@ from nova.objects import fields as obj_fields
 from nova.objects import instance as obj_instance
 from nova import rpc
 from nova.scheduler.filters import utils as filters_utils
+from nova import utils
 from nova.virt import hardware
 
 
@@ -51,11 +52,10 @@ GroupDetails = collections.namedtuple('GroupDetails', ['hosts', 'policy',
 class ResourceRequest(object):
     """Presents a granular resource request via RequestGroup instances."""
     # extra_specs-specific consts
-    XS_RES_PREFIX = 'resources'
-    XS_TRAIT_PREFIX = 'trait'
     # Regex patterns for numbered or un-numbered resources/trait keys
-    XS_KEYPAT = re.compile(r"^(%s)([1-9][0-9]*)?:(.*)$" %
-                           '|'.join((XS_RES_PREFIX, XS_TRAIT_PREFIX)))
+    XS_KEYPAT = re.compile(
+        r"^(%s)([1-9][0-9]*)?:(.*)$" %
+        '|'.join((utils.XS_RES_PREFIX, utils.XS_TRAIT_PREFIX)))
 
     def __init__(self, request_spec, enable_pinning_translate=True):
         """Create a new instance of ResourceRequest from a RequestSpec.
@@ -163,11 +163,11 @@ class ResourceRequest(object):
             prefix, suffix, name = match.groups()
 
             # Process "resources[$N]"
-            if prefix == self.XS_RES_PREFIX:
+            if prefix == utils.XS_RES_PREFIX:
                 self._add_resource(suffix, name, val)
 
             # Process "trait[$N]"
-            elif prefix == self.XS_TRAIT_PREFIX:
+            elif prefix == utils.XS_TRAIT_PREFIX:
                 self._add_trait(suffix, name, val)
 
     def _process_image_meta(self, image):
diff --git a/nova/tests/fixtures.py b/nova/tests/fixtures.py
index 30d76b2..4c0bd70 100644
--- a/nova/tests/fixtures.py
+++ b/nova/tests/fixtures.py
@@ -67,6 +67,7 @@ from nova.scheduler import weights
 from nova import service
 from nova.tests.functional.api import client
 from nova.tests.unit import fake_requests
+from nova import utils
 
 _TRUE_VALUES = ('True', 'true', '1', 'yes')
 
@@ -742,6 +743,10 @@ class DefaultFlavorsFixture(fixtures.Fixture):
         extra_specs = {
             "hw:numa_nodes": "1"
         }
+        sgx_extra_specs = {
+            utils.SGX_RESOURCE_EPC: '32',
+            utils.SGX_TRAIT: 'required'
+        }
         default_flavors = [
             objects.Flavor(context=ctxt, memory_mb=512, vcpus=1,
                            root_gb=1, flavorid='1', name='m1.tiny',
@@ -749,6 +754,9 @@ class DefaultFlavorsFixture(fixtures.Fixture):
             objects.Flavor(context=ctxt, memory_mb=2048, vcpus=1,
                            root_gb=20, flavorid='2', name='m1.small',
                            **defaults),
+            objects.Flavor(context=ctxt, memory_mb=2048, vcpus=1,
+                           root_gb=20, flavorid='7', name='m1.small.sgx',
+                           extra_specs=sgx_extra_specs, **defaults),
             objects.Flavor(context=ctxt, memory_mb=4096, vcpus=2,
                            root_gb=40, flavorid='3', name='m1.medium',
                            **defaults),
diff --git a/nova/tests/unit/api/openstack/compute/test_quota_classes.py b/nova/tests/unit/api/openstack/compute/test_quota_classes.py
index c710dd3..042fcac 100644
--- a/nova/tests/unit/api/openstack/compute/test_quota_classes.py
+++ b/nova/tests/unit/api/openstack/compute/test_quota_classes.py
@@ -32,7 +32,8 @@ class QuotaClassSetsTestV21(test.TestCase):
                        'injected_file_content_bytes': 10240,
                        'security_groups': 10,
                        'security_group_rules': 20, 'key_pairs': 100,
-                       'injected_file_path_bytes': 255}
+                       'injected_file_path_bytes': 255,
+                       'sgx_epc': 1024}
     filtered_quotas = None
 
     def quota_set(self, class_name):
@@ -132,7 +133,8 @@ class QuotaClassSetsTestV250(QuotaClassSetsTestV21):
                        'key_pairs': 100,
                        'injected_file_path_bytes': 255,
                        'server_groups': 10,
-                       'server_group_members': 10}
+                       'server_group_members': 10,
+                       'sgx_epc': 1024}
     filtered_quotas = quota_classes_v21.FILTERED_QUOTAS_2_50
 
     def _check_filtered_extended_quota(self, quota_set):
diff --git a/nova/tests/unit/api/openstack/compute/test_quotas.py b/nova/tests/unit/api/openstack/compute/test_quotas.py
index 3bb987c..2acb495 100644
--- a/nova/tests/unit/api/openstack/compute/test_quotas.py
+++ b/nova/tests/unit/api/openstack/compute/test_quotas.py
@@ -32,7 +32,8 @@ def quota_set(id, include_server_group_quotas=True):
            'instances': 10, 'injected_files': 5, 'cores': 20,
            'injected_file_content_bytes': 10240,
            'security_groups': 10, 'security_group_rules': 20,
-           'key_pairs': 100, 'injected_file_path_bytes': 255}}
+           'key_pairs': 100, 'injected_file_path_bytes': 255,
+           'sgx_epc': 1024}}
     if include_server_group_quotas:
         res['quota_set']['server_groups'] = 10
         res['quota_set']['server_group_members'] = 10
@@ -67,6 +68,7 @@ class QuotaSetsTestV21(BaseQuotaSetsTest):
             'instances': 10,
             'cores': 20,
             'ram': 51200,
+            'sgx_epc': 1024,
             'floating_ips': 10,
             'fixed_ips': -1,
             'metadata_items': 128,
@@ -97,6 +99,7 @@ class QuotaSetsTestV21(BaseQuotaSetsTest):
         self.assertEqual(qs['instances'], 10)
         self.assertEqual(qs['cores'], 20)
         self.assertEqual(qs['ram'], 51200)
+        self.assertEqual(qs['sgx_epc'], 1024)
         self.assertEqual(qs['floating_ips'], 10)
         self.assertEqual(qs['fixed_ips'], -1)
         self.assertEqual(qs['metadata_items'], 128)
@@ -179,7 +182,8 @@ class QuotaSetsTestV21(BaseQuotaSetsTest):
     def test_quotas_update(self):
         self.default_quotas.update({
             'instances': 50,
-            'cores': 50
+            'cores': 50,
+            'sgx_epc': 32
         })
         body = {'quota_set': self.default_quotas}
         req = self._get_http_request()
@@ -219,7 +223,8 @@ class QuotaSetsTestV21(BaseQuotaSetsTest):
                               'injected_file_path_bytes': 0,
                               'security_groups': 0,
                               'security_group_rules': 0,
-                              'key_pairs': 100, 'fixed_ips': -1}}
+                              'key_pairs': 100, 'fixed_ips': -1,
+                              'sgx_epc': 0}}
         if self.include_server_group_quotas:
             body['quota_set']['server_groups'] = 10
             body['quota_set']['server_group_members'] = 10
@@ -349,7 +354,10 @@ class ExtendedQuotasTestV21(BaseQuotaSetsTest):
                              'reserved': 5},
                    'instances': {'limit': 100,
                                  'in_use': 0,
-                                 'reserved': 0}}
+                                 'reserved': 0},
+                   'sgx_epc': {'limit': 64,
+                               'in_use': 16,
+                               'reserved': 16}}
 
     def _setup_controller(self):
         self.controller = self.plugin.QuotaSetsController()
@@ -371,6 +379,9 @@ class ExtendedQuotasTestV21(BaseQuotaSetsTest):
             'instances': {'minimum': self.fake_quotas['instances']['in_use'] +
                                      self.fake_quotas['instances']['reserved'],
                           'maximum': -1},
+            'sgx_epc': {'minimum': self.fake_quotas['sgx_epc']['in_use'] +
+                                   self.fake_quotas['sgx_epc']['reserved'],
+                        'maximum': -1}
         }
 
     def _get_http_request(self, url=''):
@@ -451,7 +462,8 @@ class UserQuotasTestV21(BaseQuotaSetsTest):
                               'injected_file_path_bytes': 255,
                               'security_groups': 10,
                               'security_group_rules': 20,
-                              'key_pairs': 100}}
+                              'key_pairs': 100,
+                              'sgx_epc': 64}}
         if self.include_server_group_quotas:
             body['quota_set']['server_groups'] = 10
             body['quota_set']['server_group_members'] = 10
diff --git a/nova/tests/unit/compute/test_compute.py b/nova/tests/unit/compute/test_compute.py
index 77f23c3..56ae2d8 100644
--- a/nova/tests/unit/compute/test_compute.py
+++ b/nova/tests/unit/compute/test_compute.py
@@ -9055,7 +9055,8 @@ class ComputeAPITestCase(BaseTestCase):
         self.assertEqual(2, check_deltas_mock.call_count)
         call1 = mock.call(self.context, {'instances': 1,
                                          'cores': self.default_flavor.vcpus,
-                                         'ram': self.default_flavor.memory_mb},
+                                         'ram': self.default_flavor.memory_mb,
+                                         'sgx_epc': 0},
                           self.context.project_id,
                           user_id=None,
                           check_project_id=self.context.project_id,
diff --git a/nova/tests/unit/compute/test_compute_api.py b/nova/tests/unit/compute/test_compute_api.py
index c12f669..945a98d 100644
--- a/nova/tests/unit/compute/test_compute_api.py
+++ b/nova/tests/unit/compute/test_compute_api.py
@@ -1867,10 +1867,10 @@ class _ComputeAPIUnitTestMixIn(object):
             project_id, user_id = quotas_obj.ids_from_instance(self.context,
                                                                fake_inst)
             if flavor_id_passed:
-                mock_upsize.return_value = {'cores': 0, 'ram': 0}
+                mock_upsize.return_value = {'cores': 0, 'ram': 0, 'sgx_epc': 0}
 
                 proj_count = {'instances': 1, 'cores': current_flavor.vcpus,
-                              'ram': current_flavor.memory_mb}
+                              'ram': current_flavor.memory_mb, 'sgx_epc': 0}
                 user_count = proj_count.copy()
                 mock_count.return_value = {'project': proj_count,
                                            'user': user_count}
@@ -1965,7 +1965,7 @@ class _ComputeAPIUnitTestMixIn(object):
                 # The current and new flavor have the same cores/ram
                 req_cores = current_flavor.vcpus
                 req_ram = current_flavor.memory_mb
-                values = {'cores': req_cores, 'ram': req_ram}
+                values = {'cores': req_cores, 'ram': req_ram, 'sgx_epc': 0}
                 mock_limit.assert_called_once_with(
                     self.context, user_values=values, project_values=values,
                     project_id=project_id, user_id=user_id)
@@ -2027,29 +2027,32 @@ class _ComputeAPIUnitTestMixIn(object):
     def test_resize_quota_check(self, mock_check, mock_count, mock_get):
         self.flags(cores=1, group='quota')
         self.flags(ram=2048, group='quota')
-        proj_count = {'instances': 1, 'cores': 1, 'ram': 1024}
+        self.flags(sgx_epc=1024, group='quota')
+        proj_count = {'instances': 1, 'cores': 1, 'ram': 1024, 'sgx_epc': 0}
         user_count = proj_count.copy()
         mock_count.return_value = {'project': proj_count,
                                    'user': user_count}
 
-        cur_flavor = objects.Flavor(id=1, name='foo', vcpus=1, memory_mb=512,
-                                    root_gb=10, disabled=False)
+        cur_flavor = objects.Flavor(
+            id=1, name='foo', vcpus=1, memory_mb=512,
+            root_gb=10, disabled=False, extra_specs={})
         fake_inst = self._create_instance_obj()
         fake_inst.flavor = cur_flavor
-        new_flavor = objects.Flavor(id=2, name='bar', vcpus=1, memory_mb=2048,
-                                    root_gb=10, disabled=False)
+        new_flavor = objects.Flavor(
+            id=2, name='bar', vcpus=1, memory_mb=2048,
+            root_gb=10, disabled=False, extra_specs={})
         mock_get.return_value = new_flavor
         mock_check.side_effect = exception.OverQuota(
-                overs=['ram'], quotas={'cores': 1, 'ram': 2048},
-                usages={'instances': 1, 'cores': 1, 'ram': 2048},
-                headroom={'ram': 2048})
+            overs=['ram'], quotas={'cores': 1, 'ram': 2048, 'sgx_epc': 1024},
+            usages={'instances': 1, 'cores': 1, 'ram': 2048, 'sgx_epc': 0},
+            headroom={'ram': 2048})
 
         self.assertRaises(exception.TooManyInstances, self.compute_api.resize,
                           self.context, fake_inst, flavor_id='new')
         mock_check.assert_called_once_with(
                 self.context,
-                user_values={'cores': 1, 'ram': 2560},
-                project_values={'cores': 1, 'ram': 2560},
+                user_values={'cores': 1, 'ram': 2560, 'sgx_epc': 0},
+                project_values={'cores': 1, 'ram': 2560, 'sgx_epc': 0},
                 project_id=fake_inst.project_id, user_id=fake_inst.user_id)
 
     def test_migrate(self):
@@ -2218,18 +2221,19 @@ class _ComputeAPIUnitTestMixIn(object):
         mock_upsize.return_value = deltas
         quotas = {'cores': 0}
         overs = ['cores']
-        over_quota_args = dict(quotas=quotas,
-                               usages={'instances': 1, 'cores': 1, 'ram': 512},
-                               overs=overs)
+        over_quota_args = dict(
+            quotas=quotas,
+            usages={'instances': 1, 'cores': 1, 'ram': 512, 'sgx_epc': 0},
+            overs=overs)
 
         proj_count = {'instances': 1, 'cores': fake_inst.flavor.vcpus,
-                      'ram': fake_inst.flavor.memory_mb}
+                      'ram': fake_inst.flavor.memory_mb, 'sgx_epc': 0}
         user_count = proj_count.copy()
         mock_count.return_value = {'project': proj_count, 'user': user_count}
 
         req_cores = fake_inst.flavor.vcpus
         req_ram = fake_inst.flavor.memory_mb
-        values = {'cores': req_cores, 'ram': req_ram}
+        values = {'cores': req_cores, 'ram': req_ram, 'sgx_epc': 0}
         mock_limit.side_effect = exception.OverQuota(**over_quota_args)
 
         self.assertRaises(exception.TooManyInstances,
@@ -4069,7 +4073,7 @@ class _ComputeAPIUnitTestMixIn(object):
         admin_context = context.RequestContext('admin_user',
                                                'admin_project',
                                                True)
-        proj_count = {'instances': 1, 'cores': 1, 'ram': 512}
+        proj_count = {'instances': 1, 'cores': 1, 'ram': 512, 'sgx_epc': 64}
         user_count = proj_count.copy()
         quota_count.return_value = {'project': proj_count, 'user': user_count}
         instance = self._create_instance_obj()
@@ -4090,10 +4094,12 @@ class _ComputeAPIUnitTestMixIn(object):
             admin_context,
             user_values={'instances': 2,
                          'cores': 1 + instance.flavor.vcpus,
-                         'ram': 512 + instance.flavor.memory_mb},
+                         'ram': 512 + instance.flavor.memory_mb,
+                         'sgx_epc': 64},
             project_values={'instances': 2,
                             'cores': 1 + instance.flavor.vcpus,
-                            'ram': 512 + instance.flavor.memory_mb},
+                            'ram': 512 + instance.flavor.memory_mb,
+                            'sgx_epc': 64},
             project_id=instance.project_id, user_id=instance.user_id)
         update_qfd.assert_called_once_with(admin_context, instance, False)
 
@@ -4105,7 +4111,7 @@ class _ComputeAPIUnitTestMixIn(object):
     def test_restore_by_instance_owner(self, update_qfd, action_start,
                                        instance_save,
                                        quota_check, quota_count):
-        proj_count = {'instances': 1, 'cores': 1, 'ram': 512}
+        proj_count = {'instances': 1, 'cores': 1, 'ram': 512, 'sgx_epc': 0}
         user_count = proj_count.copy()
         quota_count.return_value = {'project': proj_count, 'user': user_count}
         instance = self._create_instance_obj()
@@ -4127,10 +4133,12 @@ class _ComputeAPIUnitTestMixIn(object):
             self.context,
             user_values={'instances': 2,
                          'cores': 1 + instance.flavor.vcpus,
-                         'ram': 512 + instance.flavor.memory_mb},
+                         'ram': 512 + instance.flavor.memory_mb,
+                         'sgx_epc': 0},
             project_values={'instances': 2,
                             'cores': 1 + instance.flavor.vcpus,
-                            'ram': 512 + instance.flavor.memory_mb},
+                            'ram': 512 + instance.flavor.memory_mb,
+                            'sgx_epc': 0},
             project_id=instance.project_id, user_id=instance.user_id)
         update_qfd.assert_called_once_with(self.context, instance, False)
 
diff --git a/nova/tests/unit/compute/test_compute_utils.py b/nova/tests/unit/compute/test_compute_utils.py
index f69ca66..7ad2bdb 100644
--- a/nova/tests/unit/compute/test_compute_utils.py
+++ b/nova/tests/unit/compute/test_compute_utils.py
@@ -43,6 +43,7 @@ from nova.objects import block_device as block_device_obj
 from nova.objects import fields
 from nova import rpc
 from nova import test
+from nova import utils
 from nova.tests.unit import fake_block_device
 from nova.tests.unit import fake_crypto
 from nova.tests.unit import fake_instance
@@ -1333,10 +1334,14 @@ class ComputeUtilsQuotaTestCase(test.TestCase):
     def test_upsize_quota_delta(self):
         old_flavor = objects.Flavor.get_by_name(self.context, 'm1.tiny')
         new_flavor = objects.Flavor.get_by_name(self.context, 'm1.medium')
+        old_flavor.extra_specs = {utils.SGX_RESOURCE_EPC: '32'}
+        new_flavor.extra_specs = {utils.SGX_RESOURCE_EPC: '64'}
 
         expected_deltas = {
             'cores': new_flavor['vcpus'] - old_flavor['vcpus'],
-            'ram': new_flavor['memory_mb'] - old_flavor['memory_mb']
+            'ram': new_flavor['memory_mb'] - old_flavor['memory_mb'],
+            'sgx_epc': int(new_flavor.extra_specs[utils.SGX_RESOURCE_EPC])
+                       - int(old_flavor.extra_specs[utils.SGX_RESOURCE_EPC])
         }
 
         deltas = compute_utils.upsize_quota_delta(new_flavor, old_flavor)
@@ -1345,15 +1350,18 @@ class ComputeUtilsQuotaTestCase(test.TestCase):
     @mock.patch('nova.objects.Quotas.count_as_dict')
     def test_check_instance_quota_exceeds_with_multiple_resources(self,
                                                                   mock_count):
-        quotas = {'cores': 1, 'instances': 1, 'ram': 512}
-        overs = ['cores', 'instances', 'ram']
+        quotas = {'cores': 1, 'instances': 1, 'ram': 512, 'sgx_epc': 64}
+        overs = ['cores', 'instances', 'ram', 'sgx_epc']
         over_quota_args = dict(quotas=quotas,
-                               usages={'instances': 1, 'cores': 1, 'ram': 512},
+                               usages={'instances': 1, 'cores': 1,
+                                       'ram': 512, 'sgx_epc': 64},
                                overs=overs)
         e = exception.OverQuota(**over_quota_args)
-        fake_flavor = objects.Flavor(vcpus=1, memory_mb=512)
+        extra_specs = {utils.SGX_RESOURCE_EPC: '64'}
+        fake_flavor = objects.Flavor(
+            vcpus=1, memory_mb=512, extra_specs=extra_specs)
         instance_num = 1
-        proj_count = {'instances': 1, 'cores': 1, 'ram': 512}
+        proj_count = {'instances': 1, 'cores': 1, 'ram': 512, 'sgx_epc': 64}
         user_count = proj_count.copy()
         mock_count.return_value = {'project': proj_count, 'user': user_count}
         with mock.patch.object(objects.Quotas, 'limit_check_project_and_user',
@@ -1364,10 +1372,11 @@ class ComputeUtilsQuotaTestCase(test.TestCase):
                                                         instance_num,
                                                         instance_num)
             except exception.TooManyInstances as e:
-                self.assertEqual('cores, instances, ram', e.kwargs['overs'])
-                self.assertEqual('1, 1, 512', e.kwargs['req'])
-                self.assertEqual('1, 1, 512', e.kwargs['used'])
-                self.assertEqual('1, 1, 512', e.kwargs['allowed'])
+                self.assertEqual(
+                    'cores, instances, ram, sgx_epc', e.kwargs['overs'])
+                self.assertEqual('1, 1, 512, 64', e.kwargs['req'])
+                self.assertEqual('1, 1, 512, 64', e.kwargs['used'])
+                self.assertEqual('1, 1, 512, 64', e.kwargs['allowed'])
             else:
                 self.fail("Exception not raised")
 
diff --git a/nova/tests/unit/conductor/test_conductor.py b/nova/tests/unit/conductor/test_conductor.py
index 525d673..f379c36 100644
--- a/nova/tests/unit/conductor/test_conductor.py
+++ b/nova/tests/unit/conductor/test_conductor.py
@@ -2178,7 +2178,8 @@ class ConductorTaskTestCase(_BaseTaskTestCase, test_compute.BaseTestCase):
 
         project_id = self.params['context'].project_id
         mock_check.assert_called_once_with(
-            self.params['context'], {'instances': 0, 'cores': 0, 'ram': 0},
+            self.params['context'],
+            {'instances': 0, 'cores': 0, 'ram': 0, 'sgx_epc': 0},
             project_id, user_id=None, check_project_id=project_id,
             check_user_id=None)
 
diff --git a/nova/tests/unit/db/fakes.py b/nova/tests/unit/db/fakes.py
index ef436f6..415e712 100644
--- a/nova/tests/unit/db/fakes.py
+++ b/nova/tests/unit/db/fakes.py
@@ -20,6 +20,7 @@ import copy
 import datetime
 
 from nova import exception
+from nova import utils
 
 
 class FakeModel(object):
diff --git a/nova/tests/unit/objects/test_objects.py b/nova/tests/unit/objects/test_objects.py
index a9b8883..9ccf557 100644
--- a/nova/tests/unit/objects/test_objects.py
+++ b/nova/tests/unit/objects/test_objects.py
@@ -1082,7 +1082,7 @@ object_data = {
     'InstanceGroup': '1.11-852ac511d30913ee88f3c3a869a8f30a',
     'InstanceGroupList': '1.8-90f8f1a445552bb3bbc9fa1ae7da27d4',
     'InstanceInfoCache': '1.5-cd8b96fefe0fc8d4d337243ba0bf0e1e',
-    'InstanceList': '2.6-238f125650c25d6d12722340d726f723',
+    'InstanceList': '2.6-ac6d3375d0341a4fc02411dfa283b985',
     'InstanceMapping': '1.2-3bd375e65c8eb9c45498d2f87b882e03',
     'InstanceMappingList': '1.3-d34b6ebb076d542ae0f8b440534118da',
     'InstanceNUMACell': '1.4-7c1eb9a198dee076b4de0840e45f4f55',
diff --git a/nova/tests/unit/scheduler/client/test_report.py b/nova/tests/unit/scheduler/client/test_report.py
index a68033f..2251342 100644
--- a/nova/tests/unit/scheduler/client/test_report.py
+++ b/nova/tests/unit/scheduler/client/test_report.py
@@ -30,6 +30,7 @@ from nova.scheduler import utils as scheduler_utils
 from nova import test
 from nova.tests import fixtures as nova_fixtures
 from nova.tests.unit import fake_requests
+from nova import utils
 
 
 CONF = nova.conf.CONF
@@ -4088,14 +4089,16 @@ class TestUsages(SchedulerReportClientTestCase):
         fake_project_response = fake_requests.FakeResponse(
             200, content=jsonutils.dumps(
                 {'usages': {orc.VCPU: 2,
-                            orc.MEMORY_MB: 512}}))
+                            orc.MEMORY_MB: 512,
+                            utils.SGX_RESOURCE_CLASS: 32}}))
         mock_get.side_effect = [ks_exc.ConnectFailure,
                                 ks_exc.ConnectFailure,
                                 fake_project_response]
         counts = self.client.get_usages_counts_for_quota(self.context,
                                                          'fake-project')
         self.assertEqual(3, mock_get.call_count)
-        expected = {'project': {'cores': 2, 'ram': 512}}
+        expected = {'project': {'cores': 2, 'ram': 512,
+                                'sgx_epc': 32}}
         self.assertDictEqual(expected, counts)
 
         # Project query succeeds, first project + user query has a
@@ -4104,14 +4107,16 @@ class TestUsages(SchedulerReportClientTestCase):
         fake_user_response = fake_requests.FakeResponse(
             200, content=jsonutils.dumps(
                 {'usages': {orc.VCPU: 1,
-                            orc.MEMORY_MB: 256}}))
+                            orc.MEMORY_MB: 256,
+                            utils.SGX_RESOURCE_CLASS: 16}}))
         mock_get.side_effect = [fake_project_response,
                                 ks_exc.ConnectFailure,
                                 fake_user_response]
         counts = self.client.get_usages_counts_for_quota(
             self.context, 'fake-project', user_id='fake-user')
         self.assertEqual(3, mock_get.call_count)
-        expected['user'] = {'cores': 1, 'ram': 256}
+        expected['user'] = {'cores': 1, 'ram': 256,
+                            'sgx_epc': 16}
         self.assertDictEqual(expected, counts)
 
         # Three attempts in a row have a ConnectFailure
@@ -4132,8 +4137,8 @@ class TestUsages(SchedulerReportClientTestCase):
             self.context, 'fake-project', user_id='fake-user')
 
         self.assertEqual(2, mock_get.call_count)
-        expected = {'project': {'cores': 0, 'ram': 0},
-                    'user': {'cores': 0, 'ram': 0}}
+        expected = {'project': {'cores': 0, 'ram': 0, 'sgx_epc': 0},
+                    'user': {'cores': 0, 'ram': 0, 'sgx_epc': 0}}
         self.assertDictEqual(expected, counts)
 
     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.get')
@@ -4145,6 +4150,6 @@ class TestUsages(SchedulerReportClientTestCase):
         counts = self.client.get_usages_counts_for_quota(
             self.context, 'fake-project', user_id='fake-user')
         self.assertEqual(2, mock_get.call_count)
-        expected = {'project': {'cores': 4, 'ram': 0},
-                    'user': {'cores': 4, 'ram': 0}}
+        expected = {'project': {'cores': 4, 'ram': 0, 'sgx_epc': 0},
+                    'user': {'cores': 4, 'ram': 0, 'sgx_epc': 0}}
         self.assertDictEqual(expected, counts)
diff --git a/nova/tests/unit/test_fixtures.py b/nova/tests/unit/test_fixtures.py
index d6f2aaa..725e785 100644
--- a/nova/tests/unit/test_fixtures.py
+++ b/nova/tests/unit/test_fixtures.py
@@ -340,7 +340,7 @@ class TestDefaultFlavorsFixture(testtools.TestCase):
 
         result = conn.execute("select * from flavors")
         rows = result.fetchall()
-        self.assertEqual(6, len(rows), "Rows %s" % rows)
+        self.assertEqual(7, len(rows), "Rows %s" % rows)
 
 
 class TestIndirectionAPIFixture(testtools.TestCase):
diff --git a/nova/tests/unit/test_flavors.py b/nova/tests/unit/test_flavors.py
index 1f4bed8..476e405 100644
--- a/nova/tests/unit/test_flavors.py
+++ b/nova/tests/unit/test_flavors.py
@@ -131,13 +131,14 @@ class InstanceTypeFilteringTest(test.TestCase):
     def test_no_filters(self):
         filters = None
         expected = ['m1.tiny', 'm1.small', 'm1.medium', 'm1.large',
-                    'm1.xlarge', 'm1.tiny.specs']
+                    'm1.xlarge', 'm1.tiny.specs', 'm1.small.sgx']
         self.assertFilterResults(filters, expected)
 
     def test_min_memory_mb_filter(self):
         # Exclude tiny instance which is 512 MB.
         filters = dict(min_memory_mb=513)
-        expected = ['m1.small', 'm1.medium', 'm1.large', 'm1.xlarge']
+        expected = ['m1.small', 'm1.medium', 'm1.large', 'm1.xlarge',
+                    'm1.small.sgx']
         self.assertFilterResults(filters, expected)
 
     def test_min_root_gb_filter(self):
diff --git a/nova/tests/unit/test_quota.py b/nova/tests/unit/test_quota.py
index 5490ee5..1ff2fe5 100644
--- a/nova/tests/unit/test_quota.py
+++ b/nova/tests/unit/test_quota.py
@@ -43,7 +43,8 @@ def _get_fake_get_usages(updates=None):
               'floating_ips': {'in_use': 2},
               'instances': {'in_use': 2},
               'cores': {'in_use': 4},
-              'ram': {'in_use': 10 * 1024}}
+              'ram': {'in_use': 10 * 1024},
+              'sgx_epc': {'in_use': 2}}
     if updates:
         usages.update(updates)
 
@@ -61,6 +62,7 @@ class QuotaIntegrationTestCase(test.TestCase):
         super(QuotaIntegrationTestCase, self).setUp()
         self.flags(instances=2,
                    cores=4,
+                   sgx_epc=64,
                    group='quota')
 
         self.user_id = 'admin'
@@ -100,6 +102,7 @@ class QuotaIntegrationTestCase(test.TestCase):
             # ability to count allocations in placement.
             inst.vcpus = inst.flavor.vcpus
             inst.memory_mb = inst.flavor.memory_mb
+            inst.instance_type_id = inst.flavor.id
             inst.create()
         # Create the related instance mapping which will be used in
         # _instances_cores_ram_count().
@@ -127,6 +130,25 @@ class QuotaIntegrationTestCase(test.TestCase):
         else:
             self.fail('Expected QuotaError exception')
 
+    def test_too_many_instances_sgx(self):
+        for i in range(CONF.quota.instances):
+            self._create_instance(flavor_name='m1.small.sgx')
+        image_uuid = 'cedef40a-ed67-4d10-800e-17455edce175'
+        try:
+            _type = objects.Flavor.get_by_name(self.context, 'm1.small.sgx')
+            self.compute_api.create(self.context, min_count=1, max_count=1,
+                                    instance_type=_type,
+                                    image_href=image_uuid)
+        except exception.QuotaError as e:
+            expected_kwargs = {'code': 413,
+                               'req': '1, 32',
+                               'used': '2, 64',
+                               'allowed': '2, 64',
+                               'overs': 'instances, sgx_epc'}
+            self.assertEqual(expected_kwargs, e.kwargs)
+        else:
+            self.fail('Expected QuotaError exception')
+
     def test_too_many_cores(self):
         self._create_instance()
         image_uuid = 'cedef40a-ed67-4d10-800e-17455edce175'
@@ -231,6 +253,7 @@ class QuotaIntegrationTestCase(test.TestCase):
                    instance_type=self.inst_type,
                    image_href=image_uuid)
 
+
     def test_max_injected_files(self):
         files = []
         for i in range(CONF.quota.injected_files):
@@ -563,6 +586,7 @@ class DbQuotaDriverTestCase(test.TestCase):
         self.flags(instances=10,
                    cores=20,
                    ram=50 * 1024,
+                   sgx_epc=64,
                    floating_ips=10,
                    fixed_ips=10,
                    metadata_items=128,
@@ -591,6 +615,7 @@ class DbQuotaDriverTestCase(test.TestCase):
                 instances=5,
                 cores=20,
                 ram=25 * 1024,
+                sgx_epc=32,
                 floating_ips=10,
                 fixed_ips=10,
                 metadata_items=64,
@@ -611,6 +636,7 @@ class DbQuotaDriverTestCase(test.TestCase):
             return dict(
                 instances=5,
                 ram=25 * 1024,
+                sgx_epc=32,
                 metadata_items=64,
                 injected_file_content_bytes=5 * 1024,
                 )
@@ -624,6 +650,7 @@ class DbQuotaDriverTestCase(test.TestCase):
             return dict(
                 instances=5,
                 ram=25 * 1024,
+                sgx_epc=16,
                 metadata_items=64,
                 injected_file_content_bytes=5 * 1024,
                 )
@@ -639,6 +666,7 @@ class DbQuotaDriverTestCase(test.TestCase):
                 instances=5,
                 cores=20,
                 ram=25 * 1024,
+                sgx_epc=16,
                 floating_ips=10,
                 fixed_ips=10,
                 metadata_items=64,
@@ -659,6 +687,7 @@ class DbQuotaDriverTestCase(test.TestCase):
             self.assertEqual(user_id, 'fake_user')
             return dict(
                 cores=10,
+                sgx_epc=8,
                 injected_files=2,
                 injected_file_path_bytes=127,
                 )
@@ -668,6 +697,7 @@ class DbQuotaDriverTestCase(test.TestCase):
             self.assertEqual(project_id, 'test_project')
             return {
                 'cores': 10,
+                'sgx_epc': 16,
                 'injected_files': 2,
                 'injected_file_path_bytes': 127,
                 }
@@ -681,8 +711,12 @@ class DbQuotaDriverTestCase(test.TestCase):
     def _get_fake_countable_resources(self):
         # Create several countable resources with fake count functions
         def fake_instances_cores_ram_count(*a, **k):
-            return {'project': {'instances': 2, 'cores': 4, 'ram': 1024},
-                    'user': {'instances': 1, 'cores': 2, 'ram': 512}}
+            return {
+                'project':
+                    {'instances': 2, 'cores': 4, 'ram': 1024, 'sgx_epc': 4},
+                'user':
+                    {'instances': 1, 'cores': 2, 'ram': 512, 'sgx_epc': 2}
+            }
 
         def fake_security_group_count(*a, **k):
             return {'project': {'security_groups': 2},
@@ -702,6 +736,8 @@ class DbQuotaDriverTestCase(test.TestCase):
             'cores', fake_instances_cores_ram_count, 'cores')
         resources['ram'] = quota.CountableResource(
             'ram', fake_instances_cores_ram_count, 'ram')
+        resources['sgx_epc'] = quota.CountableResource(
+            'sgx_epc', fake_instances_cores_ram_count, 'sgx_epc')
         resources['security_groups'] = quota.CountableResource(
             'security_groups', fake_security_group_count, 'security_groups')
         resources['floating_ips'] = quota.CountableResource(
@@ -733,6 +769,7 @@ class DbQuotaDriverTestCase(test.TestCase):
                     'instances': {'in_use': 2},
                     'cores': {'in_use': 4},
                     'ram': {'in_use': 1024},
+                    'sgx_epc': {'in_use': 4},
                     'security_groups': {'in_use': 2},
                     'floating_ips': {'in_use': 4},
                     'fixed_ips': {'in_use': 5},
@@ -752,6 +789,7 @@ class DbQuotaDriverTestCase(test.TestCase):
                     'instances': {'in_use': 1},
                     'cores': {'in_use': 2},
                     'ram': {'in_use': 512},
+                    'sgx_epc': {'in_use': 2},
                     'security_groups': {'in_use': 1},
                     'floating_ips': {'in_use': 4},
                     'fixed_ips': {'in_use': 5},
@@ -790,6 +828,10 @@ class DbQuotaDriverTestCase(test.TestCase):
                     limit=25 * 1024,
                     in_use=10 * 1024,
                     ),
+               sgx_epc=dict(
+                    limit=8,
+                    in_use=2
+               ),
                floating_ips=dict(
                     limit=10,
                     in_use=2,
@@ -863,7 +905,9 @@ class DbQuotaDriverTestCase(test.TestCase):
             return [sqa_models.ProjectUserQuota(resource='instances',
                                                 hard_limit=5),
                     sqa_models.ProjectUserQuota(resource='cores',
-                                                hard_limit=2)]
+                                                hard_limit=2),
+                    sqa_models.ProjectUserQuota(resource='sgx_epc',
+                                                hard_limit=16)]
 
         self.stub_out('nova.db.api.quota_get_all_by_project', fake_qgabp)
         self.stub_out('nova.db.api.quota_get_all', fake_quota_get_all)
@@ -900,6 +944,10 @@ class DbQuotaDriverTestCase(test.TestCase):
                     limit=25 * 1024,
                     in_use=10 * 1024,
                     ),
+                sgx_epc=dict(
+                    limit=16,
+                    in_use=2,
+                ),
                floating_ips=dict(
                     limit=10,
                     in_use=2,
@@ -979,6 +1027,11 @@ class DbQuotaDriverTestCase(test.TestCase):
                     in_use=10 * 1024,
                     remains=25 * 1024,
                     ),
+                sgx_epc=dict(
+                    limit=16,
+                    in_use=2,
+                    remains=0,
+                ),
                 floating_ips=dict(
                     limit=10,
                     in_use=2,
@@ -1065,6 +1118,10 @@ class DbQuotaDriverTestCase(test.TestCase):
                     limit=50 * 1024,
                     in_use=10 * 1024,
                     ),
+                sgx_epc=dict(
+                    limit=8,
+                    in_use=2,
+                    ),
                 floating_ips=dict(
                     limit=10,
                     in_use=2,
@@ -1139,6 +1196,10 @@ class DbQuotaDriverTestCase(test.TestCase):
                     limit=25 * 1024,
                     in_use=10 * 1024,
                     ),
+                sgx_epc=dict(
+                    limit=32,
+                    in_use=2,
+                    ),
                floating_ips=dict(
                     limit=10,
                     in_use=2,
@@ -1216,6 +1277,10 @@ class DbQuotaDriverTestCase(test.TestCase):
                     limit=25 * 1024,
                     in_use=10 * 1024,
                     ),
+                sgx_epc=dict(
+                    limit=8,
+                    in_use=2,
+                    ),
                 floating_ips=dict(
                     limit=10,
                     in_use=2,
@@ -1292,6 +1357,10 @@ class DbQuotaDriverTestCase(test.TestCase):
                     limit=25 * 1024,
                     in_use=10 * 1024,
                     ),
+                sgx_epc=dict(
+                    limit=16,
+                    in_use=2,
+                    ),
                 floating_ips=dict(
                     limit=10,
                     in_use=2,
@@ -1359,6 +1428,9 @@ class DbQuotaDriverTestCase(test.TestCase):
                 ram=dict(
                     limit=25 * 1024,
                     ),
+                sgx_epc=dict(
+                    limit=8,
+                    ),
                 floating_ips=dict(
                     limit=10,
                     ),
@@ -1415,6 +1487,9 @@ class DbQuotaDriverTestCase(test.TestCase):
                 ram=dict(
                     limit=25 * 1024,
                     ),
+                sgx_epc=dict(
+                    limit=16,
+                    ),
                 floating_ips=dict(
                     limit=10,
                     ),
@@ -1471,6 +1546,10 @@ class DbQuotaDriverTestCase(test.TestCase):
                     remains = -1
                     in_use = 5
                     limit = -1
+                elif k== 'sgx_epc':
+                    remains = 2
+                    in_use = 4
+                    limit = 16
                 elif k == 'floating_ips':
                     remains = 20
                     in_use = 0
@@ -1494,6 +1573,8 @@ class DbQuotaDriverTestCase(test.TestCase):
                     in_use = 1
                 elif k == 'cores':
                     in_use = 15
+                elif k == 'sgx_epc':
+                    in_use = 2
                 else:
                     in_use = 0
                 result[k] = {'limit': v.default,
@@ -1502,7 +1583,7 @@ class DbQuotaDriverTestCase(test.TestCase):
 
         def fake_qgabpau(context, project_id, user_id):
             self.calls.append('quota_get_all_by_project_and_user')
-            return {'instances': 2, 'cores': -1}
+            return {'instances': 2, 'cores': -1, 'sgx_epc': 8}
 
         self.stub_out('nova.db.api.quota_get_all_by_project',
                        fake_quota_get_all_by_project)
@@ -1538,6 +1619,10 @@ class DbQuotaDriverTestCase(test.TestCase):
                     'minimum': 0,
                     'maximum': 50 * 1024,
                     },
+                'sgx_epc': {
+                    'minimum': 2,
+                    'maximum': 10,
+                    },
                 'floating_ips': {
                     'minimum': 0,
                     'maximum': 20,
@@ -1607,6 +1692,10 @@ class DbQuotaDriverTestCase(test.TestCase):
                     'minimum': 0,
                     'maximum': -1,
                     },
+                'sgx_epc': {
+                    'minimum': 14,
+                    'maximum': -1,
+                    },
                 'floating_ips': {
                     'minimum': 0,
                     'maximum': -1,
@@ -1678,6 +1767,10 @@ class DbQuotaDriverTestCase(test.TestCase):
                     'minimum': 0,
                     'maximum': 50 * 1024,
                     },
+                'sgx_epc': {
+                     'minimum': 2,
+                     'maximum': 10,
+                    },
                 'floating_ips': {
                     'minimum': 0,
                     'maximum': 20,
diff --git a/nova/tests/unit/virt/libvirt/test_driver.py b/nova/tests/unit/virt/libvirt/test_driver.py
index e40cc43..7fffc85 100644
--- a/nova/tests/unit/virt/libvirt/test_driver.py
+++ b/nova/tests/unit/virt/libvirt/test_driver.py
@@ -25624,7 +25624,7 @@ class TestLibvirtSGX(test.NoDBTestCase):
         guest_tmp = self.Temp({'guest': None, 'virt_type': 'kvm'})
         flavor = self.Temp(
             {'extra_specs': {
-                'resources:' + libvirt_driver.SGX_RESOURCE_CLASS: epc_size}
+                'resources:' + utils.SGX_RESOURCE_CLASS: epc_size}
             }
         )
         result = self.driver._guest_add_sgx(guest_tmp, flavor, None)
diff --git a/nova/utils.py b/nova/utils.py
index 12df254..2212d15 100644
--- a/nova/utils.py
+++ b/nova/utils.py
@@ -92,6 +92,12 @@ _FILE_CACHE = {}
 
 _SERVICE_TYPES = service_types.ServiceTypes()
 
+XS_RES_PREFIX = 'resources'
+XS_TRAIT_PREFIX = 'trait'
+SGX_RESOURCE_CLASS = "CUSTOM_SGX_EPC_MB"
+SGX_TRAIT_NAME= "HW_CPU_X86_SGX"
+SGX_RESOURCE_EPC = ':'.join([XS_RES_PREFIX, SGX_RESOURCE_CLASS])
+SGX_TRAIT = ':'.join([XS_TRAIT_PREFIX, SGX_TRAIT_NAME])
 
 if hasattr(inspect, 'getfullargspec'):
     getargspec = inspect.getfullargspec
diff --git a/nova/virt/libvirt/driver.py b/nova/virt/libvirt/driver.py
index 65c7ce0..36ce49c 100644
--- a/nova/virt/libvirt/driver.py
+++ b/nova/virt/libvirt/driver.py
@@ -162,8 +162,6 @@ CONSOLE = "console=tty0 console=ttyS0 console=hvc0"
 GuestNumaConfig = collections.namedtuple(
     'GuestNumaConfig', ['cpuset', 'cputune', 'numaconfig', 'numatune'])
 
-SGX_RESOURCE_CLASS = "CUSTOM_SGX_EPC_MB"
-
 
 class InjectionInfo(collections.namedtuple(
         'InjectionInfo', ['network_info', 'files', 'admin_pass'])):
@@ -5953,7 +5951,7 @@ class LibvirtDriver(driver.ComputeDriver):
         """Size of sgx epc memory is determined by
         `resources:CUSTOM_SGX_EPC_MB` specified in flavor extra_spec.
         """
-        epc_mb = flavor.extra_specs.get('resources:' + SGX_RESOURCE_CLASS)
+        epc_mb = flavor.extra_specs.get('resources:' + utils.SGX_RESOURCE_CLASS)
         return None if epc_mb is None else int(epc_mb)
 
     def _guest_configure_sev(self, guest, arch, mach_type):
@@ -7449,7 +7447,7 @@ class LibvirtDriver(driver.ComputeDriver):
             }
 
         if sgx_epc_mb:
-            result[SGX_RESOURCE_CLASS] = {
+            result[utils.SGX_RESOURCE_CLASS] = {
                 'total': sgx_epc_mb,
                 'min_unit': 1,
                 'max_unit': sgx_epc_mb,
-- 
2.17.1


From 3251840d71a7e2be0cd9d7d1443d6ac1597f0d02 Mon Sep 17 00:00:00 2001
From: shaleijie <sha.leijie@99cloud.net>
Date: Mon, 16 May 2022 19:06:49 +0800
Subject: [PATCH 3/5] fix quota

---
 nova/objects/flavor.py                      |  2 +-
 nova/objects/instance.py                    |  6 ++++--
 nova/quota.py                               | 14 +++++++++-----
 nova/scheduler/client/report.py             |  6 ++++--
 nova/tests/unit/compute/test_compute_api.py |  9 +++++----
 nova/tests/unit/db/fakes.py                 |  1 -
 6 files changed, 23 insertions(+), 15 deletions(-)

diff --git a/nova/objects/flavor.py b/nova/objects/flavor.py
index d59f7a3..5695126 100644
--- a/nova/objects/flavor.py
+++ b/nova/objects/flavor.py
@@ -140,7 +140,7 @@ def _get_all_extra_specs_by_key(context, key):
         api_models.FlavorExtraSpecs.flavor_id,
         api_models.FlavorExtraSpecs.value).filter_by(key=key).all()
 
-    return {record[0]: int(record[1]) or 0 for record in records}
+    return {record[0]: int(record[1] or 0) for record in records}
 
 
 @db_api.api_context_manager.writer
diff --git a/nova/objects/instance.py b/nova/objects/instance.py
index 0a7f6a6..13b39c3 100644
--- a/nova/objects/instance.py
+++ b/nova/objects/instance.py
@@ -1547,10 +1547,12 @@ class InstanceList(base.ObjectListBase, base.NovaObject):
 
                     {'project': {'instances': <count across project>,
                                  'cores': <count across project>,
-                                 'ram': <count across project},
+                                 'ram': <count across project>,
+                                 'sgx_epc: <count across project>},
                      'user': {'instances': <count across user>,
                               'cores': <count across user>,
-                              'ram': <count across user>}}
+                              'ram': <count across user>,
+                              'sgx_epc': <count across user>}}
         """
         return cls._get_counts_in_db(
             context, project_id, user_id=user_id, **kwargs)
diff --git a/nova/quota.py b/nova/quota.py
index d7c97a3..34a4d9f 100644
--- a/nova/quota.py
+++ b/nova/quota.py
@@ -1213,7 +1213,7 @@ def _floating_ip_count(context, project_id):
 
 
 def _instances_cores_ram_count_legacy(context, project_id, user_id=None):
-    """Get the counts of instances, cores, and ram in cell databases.
+    """Get the counts of instances, cores, sgx_epc and ram in cell databases.
 
     :param context: The request context for database access
     :param project_id: The project_id to count across
@@ -1223,10 +1223,12 @@ def _instances_cores_ram_count_legacy(context, project_id, user_id=None):
 
                 {'project': {'instances': <count across project>,
                              'cores': <count across project>,
-                             'ram': <count across project>},
+                             'ram': <count across project>,
+                             'sgx_epc': <count across project>},
                  'user': {'instances': <count across user>,
                           'cores': <count across user>,
-                          'ram': <count across user>}}
+                          'ram': <count across user>,
+                          'sgx_epc': <count across user>}}
     """
     # NOTE(melwitt): Counting across cells for instances, cores, and ram means
     # we will miss counting resources if a cell is down.
@@ -1298,10 +1300,12 @@ def _instances_cores_ram_count(context, project_id, user_id=None):
 
                 {'project': {'instances': <count across project>,
                              'cores': <count across project>,
-                             'ram': <count across project>},
+                             'ram': <count across project>,
+                             'sgx_epc': <count across project>},
                  'user': {'instances': <count across user>,
                           'cores': <count across user>,
-                          'ram': <count across user>}}
+                          'ram': <count across user>,
+                          'sgx_epc': <count across user>}}
     """
     global UID_QFD_POPULATED_CACHE_BY_PROJECT
     if CONF.quota.count_usage_from_placement:
diff --git a/nova/scheduler/client/report.py b/nova/scheduler/client/report.py
index bd3e4d8..dbb0485 100644
--- a/nova/scheduler/client/report.py
+++ b/nova/scheduler/client/report.py
@@ -2326,9 +2326,11 @@ class SchedulerReportClient(object):
         :returns: A dict containing the project-scoped and user-scoped counts
                   if user_id is specified. For example:
                     {'project': {'cores': <count across project>,
-                                 'ram': <count across project>},
+                                 'ram': <count across project>,
+                                 'sgx_epc': <count across project>},
                     {'user': {'cores': <count across user>,
-                              'ram': <count across user>},
+                              'ram': <count across user>,
+                              'sgx_epc': <count across user>},
         :raises: `exception.UsagesRetrievalFailed` if a placement API call
                  fails
         """
diff --git a/nova/tests/unit/compute/test_compute_api.py b/nova/tests/unit/compute/test_compute_api.py
index 945a98d..1f4aeb2 100644
--- a/nova/tests/unit/compute/test_compute_api.py
+++ b/nova/tests/unit/compute/test_compute_api.py
@@ -2040,19 +2040,20 @@ class _ComputeAPIUnitTestMixIn(object):
         fake_inst.flavor = cur_flavor
         new_flavor = objects.Flavor(
             id=2, name='bar', vcpus=1, memory_mb=2048,
-            root_gb=10, disabled=False, extra_specs={})
+            root_gb=10, disabled=False,
+            extra_specs={utils.SGX_RESOURCE_EPC: '32'})
         mock_get.return_value = new_flavor
         mock_check.side_effect = exception.OverQuota(
             overs=['ram'], quotas={'cores': 1, 'ram': 2048, 'sgx_epc': 1024},
-            usages={'instances': 1, 'cores': 1, 'ram': 2048, 'sgx_epc': 0},
+            usages={'instances': 1, 'cores': 1, 'ram': 1024, 'sgx_epc': 0},
             headroom={'ram': 2048})
 
         self.assertRaises(exception.TooManyInstances, self.compute_api.resize,
                           self.context, fake_inst, flavor_id='new')
         mock_check.assert_called_once_with(
                 self.context,
-                user_values={'cores': 1, 'ram': 2560, 'sgx_epc': 0},
-                project_values={'cores': 1, 'ram': 2560, 'sgx_epc': 0},
+                user_values={'cores': 1, 'ram': 2560, 'sgx_epc': 32},
+                project_values={'cores': 1, 'ram': 2560, 'sgx_epc': 32},
                 project_id=fake_inst.project_id, user_id=fake_inst.user_id)
 
     def test_migrate(self):
diff --git a/nova/tests/unit/db/fakes.py b/nova/tests/unit/db/fakes.py
index 415e712..ef436f6 100644
--- a/nova/tests/unit/db/fakes.py
+++ b/nova/tests/unit/db/fakes.py
@@ -20,7 +20,6 @@ import copy
 import datetime
 
 from nova import exception
-from nova import utils
 
 
 class FakeModel(object):
-- 
2.17.1


From 964b7532ed8c6299b7bd19241c0da326fe596acb Mon Sep 17 00:00:00 2001
From: shaleijie <sha.leijie@99cloud.net>
Date: Sun, 5 Jun 2022 23:09:23 +0800
Subject: [PATCH 4/5] fix check of flavor extra_specs

---
 nova/api/openstack/compute/flavors_extraspecs.py | 9 +++++----
 1 file changed, 5 insertions(+), 4 deletions(-)

diff --git a/nova/api/openstack/compute/flavors_extraspecs.py b/nova/api/openstack/compute/flavors_extraspecs.py
index 69e4c59..fb5bd52 100644
--- a/nova/api/openstack/compute/flavors_extraspecs.py
+++ b/nova/api/openstack/compute/flavors_extraspecs.py
@@ -33,10 +33,11 @@ class FlavorExtraSpecsController(wsgi.Controller):
         return dict(extra_specs=flavor.extra_specs)
 
     def _extra_check_for_sgx_epc(self, value):
-        if isinstance(value, (six.integer_types,)) and value > 0:
-            return
-        raise exception.InvalidInput(
-            reason="%s must be a positive integer." % utils.SGX_RESOURCE_EPC)
+        try:
+            int(value)
+        except ValueError:
+            raise exception.InvalidInput(
+                reason="%s must be a positive integer." % utils.SGX_RESOURCE_EPC)
 
     # NOTE(gmann): Max length for numeric value is being checked
     # explicitly as json schema cannot have max length check for numeric value
-- 
2.17.1


From af1d2bfa119310c7d71c9816f64d4555c49b8dc9 Mon Sep 17 00:00:00 2001
From: shaleijie <sha.leijie@99cloud.net>
Date: Fri, 15 Jul 2022 22:20:31 +0800
Subject: [PATCH 5/5] Support for SDL tests

---
 nova/api/openstack/compute/flavors_extraspecs.py |  5 +++++
 nova/tests/unit/virt/libvirt/test_driver.py      |  4 ++++
 nova/tests/unit/virt/libvirt/test_host.py        | 15 +++++++++++++++
 nova/virt/libvirt/host.py                        |  4 ++++
 4 files changed, 28 insertions(+)

diff --git a/nova/api/openstack/compute/flavors_extraspecs.py b/nova/api/openstack/compute/flavors_extraspecs.py
index fb5bd52..cddcc52 100644
--- a/nova/api/openstack/compute/flavors_extraspecs.py
+++ b/nova/api/openstack/compute/flavors_extraspecs.py
@@ -95,6 +95,11 @@ class FlavorExtraSpecsController(wsgi.Controller):
             expl = _('Request body and URI mismatch')
             raise webob.exc.HTTPBadRequest(explanation=expl)
         flavor = common.get_flavor(context, flavor_id)
+        if utils.SGX_RESOURCE_EPC in flavor.extra_specs:
+            expl = _('Update %(spec)s in extra spec of flavor %(flavor_id)'
+                     ' is forbidden.') % dict(spec=utils.SGX_RESOURCE_EPC,
+                                              flavor_id=flavor_id)
+            raise webob.exc.HTTPConflict(explanation=expl)
         try:
             flavor.extra_specs = dict(flavor.extra_specs, **body)
             flavor.save()
diff --git a/nova/tests/unit/virt/libvirt/test_driver.py b/nova/tests/unit/virt/libvirt/test_driver.py
index 7fffc85..90656dc 100644
--- a/nova/tests/unit/virt/libvirt/test_driver.py
+++ b/nova/tests/unit/virt/libvirt/test_driver.py
@@ -114,6 +114,7 @@ from nova.virt.libvirt import firewall
 from nova.virt.libvirt import guest as libvirt_guest
 from nova.virt.libvirt import host
 from nova.virt.libvirt.host import SEV_KERNEL_PARAM_FILE
+from nova.virt.libvirt.host import SGX_KERNEL_PARAM_FILE
 from nova.virt.libvirt import imagebackend
 from nova.virt.libvirt import imagecache
 from nova.virt.libvirt import migration as libvirt_migrate
@@ -6399,6 +6400,7 @@ class LibvirtConnTestCase(test.NoDBTestCase,
 
     @mock.patch('nova.virt.libvirt.driver.os.path.exists')
     @test.patch_exists(SEV_KERNEL_PARAM_FILE, False)
+    @test.patch_exists(SGX_KERNEL_PARAM_FILE, False)
     def test_get_guest_config_with_rng_backend(self, mock_path):
         self.flags(virt_type='kvm',
                    rng_dev_path='/dev/hw_rng',
@@ -7078,6 +7080,7 @@ class LibvirtConnTestCase(test.NoDBTestCase,
     @mock.patch.object(libvirt_driver.LibvirtDriver, "_has_numa_support")
     @mock.patch('os.path.exists', return_value=True)
     @test.patch_exists(SEV_KERNEL_PARAM_FILE, False)
+    @test.patch_exists(SGX_KERNEL_PARAM_FILE, False)
     def test_get_guest_config_aarch64(self, mock_path_exists,
                                       mock_numa, mock_storage, mock_get_arch):
         def get_host_capabilities_stub(self):
@@ -7133,6 +7136,7 @@ class LibvirtConnTestCase(test.NoDBTestCase,
     @mock.patch.object(libvirt_driver.LibvirtDriver, "_has_numa_support")
     @mock.patch('os.path.exists', return_value=True)
     @test.patch_exists(SEV_KERNEL_PARAM_FILE, False)
+    @test.patch_exists(SGX_KERNEL_PARAM_FILE, False)
     def test_get_guest_config_aarch64_with_graphics(self, mock_path_exists,
                                                     mock_numa, mock_storage,
                                                     mock_get_arch):
diff --git a/nova/tests/unit/virt/libvirt/test_host.py b/nova/tests/unit/virt/libvirt/test_host.py
index 8ba12f8..893cf6f 100644
--- a/nova/tests/unit/virt/libvirt/test_host.py
+++ b/nova/tests/unit/virt/libvirt/test_host.py
@@ -1372,6 +1372,21 @@ class TestLibvirtSGXSupport(test.NoDBTestCase):
         self.assertFalse(self.host._kernel_supports_intel_sgx())
         fake_exists.assert_called_once_with(host.SGX_KERNEL_PARAM_FILE)
 
+    @mock.patch.object(os.path, 'exists', return_value=True)
+    @mock.patch.object(os.path, 'islink', return_value=True)
+    def test_kernel_parameter_link_fail(self, fake_exists, fake_islink):
+        self.assertFalse(self.host._kernel_supports_intel_sgx())
+        fake_exists.assert_called_once_with(host.SGX_KERNEL_PARAM_FILE)
+        fake_islink.assert_called_once_with(host.SGX_KERNEL_PARAM_FILE)
+
+    @mock.patch.object(os.path, 'exists', return_value=True)
+    @mock.patch.object(os.path, 'islink', return_value=False)
+    @mock.patch.object(builtins, 'open', mock.mock_open(read_data="N\n"))
+    def test_kernel_parameter_link_pass(self, fake_exists, fake_islink):
+        self.assertFalse(self.host._kernel_supports_intel_sgx())
+        fake_exists.assert_called_once_with(host.SGX_KERNEL_PARAM_FILE)
+        fake_islink.assert_called_once_with(host.SGX_KERNEL_PARAM_FILE)
+
     @mock.patch('nova.virt.libvirt.host.Host._kernel_supports_intel_sgx',
                 new=mock.Mock(return_value=True))
     def test_supports_intel_sgx(self):
diff --git a/nova/virt/libvirt/host.py b/nova/virt/libvirt/host.py
index 481aae0..519999a 100644
--- a/nova/virt/libvirt/host.py
+++ b/nova/virt/libvirt/host.py
@@ -1237,6 +1237,10 @@ class Host(object):
             LOG.debug("%s does not exist", SGX_KERNEL_PARAM_FILE)
             return False
 
+        if os.path.islink(SGX_KERNEL_PARAM_FILE):
+            LOG.error("%s is a soft link file", SGX_KERNEL_PARAM_FILE)
+            return False
+
         with open(SGX_KERNEL_PARAM_FILE) as f:
             contents = f.read()
             LOG.debug("%s contains [%s]", SGX_KERNEL_PARAM_FILE, contents)
-- 
2.17.1

